(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("@angular/core"), require("@angular/forms"), require("@angular/common"));
	else if(typeof define === 'function' && define.amd)
		define(["@angular/core", "@angular/forms", "@angular/common"], factory);
	else if(typeof exports === 'object')
		exports["ng2-tag-input"] = factory(require("@angular/core"), require("@angular/forms"), require("@angular/common"));
	else
		root["ng2-tag-input"] = factory(root["@angular/core"], root["@angular/forms"], root["@angular/common"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdateng2_tag_input"];
/******/ 	this["webpackHotUpdateng2_tag_input"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
/******/ 		if(typeof XMLHttpRequest === "undefined")
/******/ 			return callback(new Error("No browser support"));
/******/ 		try {
/******/ 			var request = new XMLHttpRequest();
/******/ 			var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 			request.open("GET", requestPath, true);
/******/ 			request.timeout = 10000;
/******/ 			request.send(null);
/******/ 		} catch(err) {
/******/ 			return callback(err);
/******/ 		}
/******/ 		request.onreadystatechange = function() {
/******/ 			if(request.readyState !== 4) return;
/******/ 			if(request.status === 0) {
/******/ 				// timeout
/******/ 				callback(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 			} else if(request.status === 404) {
/******/ 				// no update available
/******/ 				callback();
/******/ 			} else if(request.status !== 200 && request.status !== 304) {
/******/ 				// other failure
/******/ 				callback(new Error("Manifest request to " + requestPath + " failed."));
/******/ 			} else {
/******/ 				// success
/******/ 				try {
/******/ 					var update = JSON.parse(request.responseText);
/******/ 				} catch(e) {
/******/ 					callback(e);
/******/ 					return;
/******/ 				}
/******/ 				callback(null, update);
/******/ 			}
/******/ 		};
/******/ 	}

/******/ 	
/******/ 	
/******/ 	// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js
/******/ 	var canDefineProperty = false;
/******/ 	try {
/******/ 		Object.defineProperty({}, "x", {
/******/ 			get: function() {}
/******/ 		});
/******/ 		canDefineProperty = true;
/******/ 	} catch(x) {
/******/ 		// IE will fail on defineProperty
/******/ 	}
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "62cc267e40cdc4527ef4"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					if(me.children.indexOf(request) < 0)
/******/ 						me.children.push(request);
/******/ 				} else hotCurrentParents = [moduleId];
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {
/******/ 				if(canDefineProperty) {
/******/ 					Object.defineProperty(fn, name, (function(name) {
/******/ 						return {
/******/ 							configurable: true,
/******/ 							enumerable: true,
/******/ 							get: function() {
/******/ 								return __webpack_require__[name];
/******/ 							},
/******/ 							set: function(value) {
/******/ 								__webpack_require__[name] = value;
/******/ 							}
/******/ 						};
/******/ 					}(name)));
/******/ 				} else {
/******/ 					fn[name] = __webpack_require__[name];
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		function ensure(chunkId, callback) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			__webpack_require__.e(chunkId, function() {
/******/ 				try {
/******/ 					callback.call(null, fn);
/******/ 				} finally {
/******/ 					finishChunkLoading();
/******/ 				}
/******/ 	
/******/ 				function finishChunkLoading() {
/******/ 					hotChunksLoading--;
/******/ 					if(hotStatus === "prepare") {
/******/ 						if(!hotWaitingFilesMap[chunkId]) {
/******/ 							hotEnsureUpdateChunk(chunkId);
/******/ 						}
/******/ 						if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 							hotUpdateDownloaded();
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		}
/******/ 		if(canDefineProperty) {
/******/ 			Object.defineProperty(fn, "e", {
/******/ 				enumerable: true,
/******/ 				value: ensure
/******/ 			});
/******/ 		} else {
/******/ 			fn.e = ensure;
/******/ 		}
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback;
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback;
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "number")
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 				else
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailibleFilesMap = {};
/******/ 	var hotCallback;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply, callback) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		if(typeof apply === "function") {
/******/ 			hotApplyOnUpdate = false;
/******/ 			callback = apply;
/******/ 		} else {
/******/ 			hotApplyOnUpdate = apply;
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 		hotSetStatus("check");
/******/ 		hotDownloadManifest(function(err, update) {
/******/ 			if(err) return callback(err);
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				callback(null, null);
/******/ 				return;
/******/ 			}
/******/ 	
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotAvailibleFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			for(var i = 0; i < update.c.length; i++)
/******/ 				hotAvailibleFilesMap[update.c[i]] = true;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			hotCallback = callback;
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailibleFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var callback = hotCallback;
/******/ 		hotCallback = null;
/******/ 		if(!callback) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate, callback);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			callback(null, outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options, callback) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		if(typeof options === "function") {
/******/ 			callback = options;
/******/ 			options = {};
/******/ 		} else if(options && typeof options === "object") {
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		} else {
/******/ 			options = {};
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function getAffectedStuff(module) {
/******/ 			var outdatedModules = [module];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice();
/******/ 			while(queue.length > 0) {
/******/ 				var moduleId = queue.pop();
/******/ 				var module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return new Error("Aborted because of self decline: " + moduleId);
/******/ 				}
/******/ 				if(moduleId === 0) {
/******/ 					return;
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push(parentId);
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return [outdatedModules, outdatedDependencies];
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				var moduleId = toModuleId(id);
/******/ 				var result = getAffectedStuff(moduleId);
/******/ 				if(!result) {
/******/ 					if(options.ignoreUnaccepted)
/******/ 						continue;
/******/ 					hotSetStatus("abort");
/******/ 					return callback(new Error("Aborted because " + moduleId + " is not accepted"));
/******/ 				}
/******/ 				if(result instanceof Error) {
/******/ 					hotSetStatus("abort");
/******/ 					return callback(result);
/******/ 				}
/******/ 				appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 				addAllToSet(outdatedModules, result[0]);
/******/ 				for(var moduleId in result[1]) {
/******/ 					if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
/******/ 						if(!outdatedDependencies[moduleId])
/******/ 							outdatedDependencies[moduleId] = [];
/******/ 						addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(var i = 0; i < outdatedModules.length; i++) {
/******/ 			var moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			var moduleId = queue.pop();
/******/ 			var module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(var j = 0; j < disposeHandlers.length; j++) {
/******/ 				var cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(var j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				var idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 					var dependency = moduleOutdatedDependencies[j];
/******/ 					var idx = module.children.indexOf(dependency);
/******/ 					if(idx >= 0) module.children.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(var moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					var dependency = moduleOutdatedDependencies[i];
/******/ 					var cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(var i = 0; i < callbacks.length; i++) {
/******/ 					var cb = callbacks[i];
/******/ 					try {
/******/ 						cb(outdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			var moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else if(!error)
/******/ 					error = err;
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return callback(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		callback(null, outdatedModules);
/******/ 	}

/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: hotCurrentParents,
/******/ 			children: []
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };

/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(1);
	var forms_1 = __webpack_require__(2);
	var common_1 = __webpack_require__(3);
	var ng2_material_dropdown_1 = __webpack_require__(4);
	var icon_1 = __webpack_require__(5);
	var tag_input_form_1 = __webpack_require__(9);
	exports.TagInputForm = tag_input_form_1.TagInputForm;
	var components_1 = __webpack_require__(13);
	exports.TagInputComponent = components_1.TagInputComponent;
	var tag_input_dropdown_component_1 = __webpack_require__(18);
	exports.TagInputDropdown = tag_input_dropdown_component_1.TagInputDropdown;
	var highlight_pipe_1 = __webpack_require__(51);
	var tag_component_1 = __webpack_require__(38);
	var tag_ripple_component_1 = __webpack_require__(39);
	var TagInputModule = (function () {
	    function TagInputModule() {
	    }
	    TagInputModule = __decorate([
	        core_1.NgModule({
	            imports: [
	                common_1.CommonModule,
	                forms_1.ReactiveFormsModule,
	                ng2_material_dropdown_1.Ng2DropdownModule
	            ],
	            declarations: [
	                components_1.TagInputComponent,
	                icon_1.DeleteIconComponent,
	                tag_input_form_1.TagInputForm,
	                tag_component_1.TagComponent,
	                highlight_pipe_1.HighlightPipe,
	                tag_input_dropdown_component_1.TagInputDropdown,
	                tag_ripple_component_1.TagRipple
	            ],
	            exports: [
	                components_1.TagInputComponent,
	                icon_1.DeleteIconComponent,
	                tag_input_form_1.TagInputForm,
	                tag_component_1.TagComponent,
	                highlight_pipe_1.HighlightPipe,
	                tag_input_dropdown_component_1.TagInputDropdown,
	                tag_ripple_component_1.TagRipple
	            ]
	        }), 
	        __metadata('design:paramtypes', [])
	    ], TagInputModule);
	    return TagInputModule;
	}());
	exports.TagInputModule = TagInputModule;
		

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory(__webpack_require__(1), __webpack_require__(3));
		else if(typeof define === 'function' && define.amd)
			define(["@angular/core", "@angular/common"], factory);
		else if(typeof exports === 'object')
			exports["ng2-dropdown"] = factory(require("@angular/core"), require("@angular/common"));
		else
			root["ng2-dropdown"] = factory(root["@angular/core"], root["@angular/common"]);
	})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_18__) {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		function __export(m) {
		    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
		}
		__export(__webpack_require__(1));
		

	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
		    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
		    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
		    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
		    return c > 3 && r && Object.defineProperty(target, key, r), r;
		};
		var __metadata = (this && this.__metadata) || function (k, v) {
		    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
		};
		var ng2_dropdown_1 = __webpack_require__(2);
		exports.Ng2Dropdown = ng2_dropdown_1.Ng2Dropdown;
		var ng2_dropdown_menu_1 = __webpack_require__(7);
		exports.Ng2DropdownMenu = ng2_dropdown_menu_1.Ng2DropdownMenu;
		var ng2_dropdown_button_1 = __webpack_require__(4);
		exports.Ng2DropdownButton = ng2_dropdown_button_1.Ng2DropdownButton;
		var ng2_menu_item_1 = __webpack_require__(9);
		exports.Ng2MenuItem = ng2_menu_item_1.Ng2MenuItem;
		var core_1 = __webpack_require__(3);
		var common_1 = __webpack_require__(18);
		var dropdown_state_service_1 = __webpack_require__(10);
		exports.DropdownStateService = dropdown_state_service_1.DropdownStateService;
		var Ng2DropdownModule = (function () {
		    function Ng2DropdownModule() {
		    }
		    Ng2DropdownModule = __decorate([
		        core_1.NgModule({
		            exports: [
		                ng2_menu_item_1.Ng2MenuItem,
		                ng2_dropdown_button_1.Ng2DropdownButton,
		                ng2_dropdown_menu_1.Ng2DropdownMenu,
		                ng2_dropdown_1.Ng2Dropdown
		            ],
		            declarations: [
		                ng2_dropdown_1.Ng2Dropdown,
		                ng2_menu_item_1.Ng2MenuItem,
		                ng2_dropdown_button_1.Ng2DropdownButton,
		                ng2_dropdown_menu_1.Ng2DropdownMenu,
		            ],
		            imports: [common_1.CommonModule]
		        }), 
		        __metadata('design:paramtypes', [])
		    ], Ng2DropdownModule);
		    return Ng2DropdownModule;
		}());
		exports.Ng2DropdownModule = Ng2DropdownModule;
			

	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
		    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
		    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
		    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
		    return c > 3 && r && Object.defineProperty(target, key, r), r;
		};
		var __metadata = (this && this.__metadata) || function (k, v) {
		    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
		};
		var core_1 = __webpack_require__(3);
		var ng2_dropdown_button_1 = __webpack_require__(4);
		var ng2_dropdown_menu_1 = __webpack_require__(7);
		var dropdown_state_service_1 = __webpack_require__(10);
		var Ng2Dropdown = (function () {
		    function Ng2Dropdown(state) {
		        this.state = state;
		        this.dynamicUpdate = true;
		        this.onItemClicked = new core_1.EventEmitter();
		        this.onItemSelected = new core_1.EventEmitter();
		        this.onShow = new core_1.EventEmitter();
		        this.onHide = new core_1.EventEmitter();
		    }
		    Ng2Dropdown.prototype.toggleMenu = function (position) {
		        if (position === void 0) { position = this.button.getPosition(); }
		        this.state.menuState.isVisible ? this.hide() : this.show(position);
		    };
		    Ng2Dropdown.prototype.hide = function () {
		        this.menu.hide();
		        this.onHide.emit(this);
		    };
		    Ng2Dropdown.prototype.show = function (position) {
		        if (position === void 0) { position = this.button.getPosition(); }
		        this.menu.show();
		        this.menu.updatePosition(position);
		        this.onShow.emit(this);
		    };
		    Ng2Dropdown.prototype.scrollListener = function () {
		        if (this.state.menuState.isVisible && this.button && this.dynamicUpdate) {
		            this.menu.updatePosition(this.button.getPosition());
		        }
		    };
		    Ng2Dropdown.prototype.ngOnInit = function () {
		        var _this = this;
		        this.state.dropdownState.onItemClicked.subscribe(function (item) {
		            _this.onItemClicked.emit(item);
		            if (item.preventClose) {
		                return;
		            }
		            _this.hide.call(_this);
		        });
		        if (this.button) {
		            this.button.onMenuToggled.subscribe(function () {
		                _this.toggleMenu();
		            });
		        }
		        this.state.dropdownState.onItemSelected.subscribe(function (item) { return _this.onItemSelected.emit(item); });
		    };
		    __decorate([
		        core_1.ContentChild(ng2_dropdown_button_1.Ng2DropdownButton), 
		        __metadata('design:type', ng2_dropdown_button_1.Ng2DropdownButton)
		    ], Ng2Dropdown.prototype, "button", void 0);
		    __decorate([
		        core_1.ContentChild(ng2_dropdown_menu_1.Ng2DropdownMenu), 
		        __metadata('design:type', ng2_dropdown_menu_1.Ng2DropdownMenu)
		    ], Ng2Dropdown.prototype, "menu", void 0);
		    __decorate([
		        core_1.Input(), 
		        __metadata('design:type', Boolean)
		    ], Ng2Dropdown.prototype, "dynamicUpdate", void 0);
		    __decorate([
		        core_1.Output(), 
		        __metadata('design:type', core_1.EventEmitter)
		    ], Ng2Dropdown.prototype, "onItemClicked", void 0);
		    __decorate([
		        core_1.Output(), 
		        __metadata('design:type', core_1.EventEmitter)
		    ], Ng2Dropdown.prototype, "onItemSelected", void 0);
		    __decorate([
		        core_1.Output(), 
		        __metadata('design:type', core_1.EventEmitter)
		    ], Ng2Dropdown.prototype, "onShow", void 0);
		    __decorate([
		        core_1.Output(), 
		        __metadata('design:type', core_1.EventEmitter)
		    ], Ng2Dropdown.prototype, "onHide", void 0);
		    __decorate([
		        core_1.HostListener('window:scroll'), 
		        __metadata('design:type', Function), 
		        __metadata('design:paramtypes', []), 
		        __metadata('design:returntype', void 0)
		    ], Ng2Dropdown.prototype, "scrollListener", null);
		    Ng2Dropdown = __decorate([
		        core_1.Component({
		            selector: 'ng2-dropdown',
		            styles: [__webpack_require__(16)],
		            template: __webpack_require__(17),
		            providers: [dropdown_state_service_1.DropdownStateService]
		        }), 
		        __metadata('design:paramtypes', [dropdown_state_service_1.DropdownStateService])
		    ], Ng2Dropdown);
		    return Ng2Dropdown;
		}());
		exports.Ng2Dropdown = Ng2Dropdown;
		

	/***/ },
	/* 3 */
	/***/ function(module, exports) {

		module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
		    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
		    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
		    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
		    return c > 3 && r && Object.defineProperty(target, key, r), r;
		};
		var __metadata = (this && this.__metadata) || function (k, v) {
		    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
		};
		var core_1 = __webpack_require__(3);
		var Ng2DropdownButton = (function () {
		    function Ng2DropdownButton(element) {
		        this.element = element;
		        this.onMenuToggled = new core_1.EventEmitter();
		        this.showCaret = true;
		    }
		    Ng2DropdownButton.prototype.toggleMenu = function () {
		        this.onMenuToggled.emit(true);
		    };
		    Ng2DropdownButton.prototype.getPosition = function () {
		        return this.element.nativeElement.getBoundingClientRect();
		    };
		    __decorate([
		        core_1.Output(), 
		        __metadata('design:type', core_1.EventEmitter)
		    ], Ng2DropdownButton.prototype, "onMenuToggled", void 0);
		    __decorate([
		        core_1.Input(), 
		        __metadata('design:type', Boolean)
		    ], Ng2DropdownButton.prototype, "showCaret", void 0);
		    Ng2DropdownButton = __decorate([
		        core_1.Component({
		            selector: 'ng2-dropdown-button',
		            styles: [__webpack_require__(5)],
		            template: __webpack_require__(6)
		        }), 
		        __metadata('design:paramtypes', [core_1.ElementRef])
		    ], Ng2DropdownButton);
		    return Ng2DropdownButton;
		}());
		exports.Ng2DropdownButton = Ng2DropdownButton;
		

	/***/ },
	/* 5 */
	/***/ function(module, exports) {

		module.exports = ".ng2-dropdown-button {\n  font-family: \"Roboto\", \"Helvetica Neue\", Helvetica, Arial;\n  background: #fff;\n  padding: 0.45rem 0.25rem;\n  font-size: 14px;\n  letter-spacing: 0.08rem;\n  color: #444;\n  outline: 0;\n  cursor: pointer;\n  font-weight: 400;\n  border: none;\n  border-bottom: 1px solid #efefef;\n  text-align: left;\n  min-width: 100px;\n  width: 100%;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: row;\n          flex-direction: row;\n  max-width: 150px; }\n\n.ng2-dropdown-button:hover {\n  color: #222; }\n\n.ng2-dropdown-button:active, .ng2-dropdown-button:focus {\n  color: #222;\n  border-bottom: 2px solid #2196F3; }\n\n.ng2-dropdown-button__label {\n  -webkit-box-flex: 1;\n      -ms-flex: 1 1 95%;\n          flex: 1 1 95%; }\n\n.ng2-dropdown-button__caret {\n  width: 12px;\n  height: 12px;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-flex: 1;\n      -ms-flex: 1 1 6%;\n          flex: 1 1 6%; }\n\n:host-context(.ng2-dropdown-button--icon) .ng2-dropdown-button {\n  border: none;\n  min-width: 40px;\n  width: 40px;\n  border-radius: 100%;\n  -webkit-transition: all 0.2s;\n  transition: all 0.2s;\n  text-align: center;\n  height: 40px;\n  padding: 0.5em; }\n\n:host-context(.ng2-dropdown-button--icon) .ng2-dropdown-button:active {\n  background: rgba(0, 0, 0, 0.2); }\n"

	/***/ },
	/* 6 */
	/***/ function(module, exports) {

		module.exports = "<button class='ng2-dropdown-button' type=\"button\" (click)=\"toggleMenu()\" tabindex=\"0s\">\n    <span class=\"ng2-dropdown-button__label\">\n        <ng-content></ng-content>\n    </span>\n\n    <span class=\"ng2-dropdown-button__caret\" *ngIf=\"showCaret\">\n        <svg enable-background=\"new 0 0 32 32\" height=\"16px\" id=\"Слой_1\" version=\"1.1\" viewBox=\"0 0 32 32\" width=\"16px\" xml:space=\"preserve\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><path d=\"M24.285,11.284L16,19.571l-8.285-8.288c-0.395-0.395-1.034-0.395-1.429,0  c-0.394,0.395-0.394,1.035,0,1.43l8.999,9.002l0,0l0,0c0.394,0.395,1.034,0.395,1.428,0l8.999-9.002  c0.394-0.395,0.394-1.036,0-1.431C25.319,10.889,24.679,10.889,24.285,11.284z\" fill=\"#121313\" id=\"Expand_More\"/><g/><g/><g/><g/><g/><g/></svg>\n    </span>\n</button>\n";

	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
		    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
		    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
		    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
		    return c > 3 && r && Object.defineProperty(target, key, r), r;
		};
		var __metadata = (this && this.__metadata) || function (k, v) {
		    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
		};
		var core_1 = __webpack_require__(3);
		var actions_1 = __webpack_require__(8);
		var ng2_menu_item_1 = __webpack_require__(9);
		var dropdown_state_service_1 = __webpack_require__(10);
		var Ng2DropdownMenu = (function () {
		    function Ng2DropdownMenu(state, element, renderer) {
		        this.state = state;
		        this.element = element;
		        this.renderer = renderer;
		        this.width = 4;
		        this.focusFirstElement = true;
		    }
		    Ng2DropdownMenu.prototype.show = function () {
		        this.renderer.setElementStyle(this.getMenuElement(), 'display', 'block');
		        this.state.menuState.isVisible = true;
		        if (this.focusFirstElement) {
		            this.state.dropdownState.select(this.items.first, false);
		        }
		        window.addEventListener('keydown', actions_1.arrowKeysHandler, false);
		    };
		    Ng2DropdownMenu.prototype.hide = function () {
		        this.state.menuState.isVisible = false;
		        this.renderer.setElementStyle(this.getMenuElement(), 'display', 'none');
		        this.state.dropdownState.unselect();
		        window.removeEventListener('keydown', actions_1.arrowKeysHandler, false);
		    };
		    Ng2DropdownMenu.prototype.updatePosition = function (position) {
		        this.position = position;
		        this.ngDoCheck();
		    };
		    Ng2DropdownMenu.prototype.handleKeypress = function ($event) {
		        if (this.state.menuState.isVisible === false) {
		            return;
		        }
		        var key = $event.keyCode, items = this.items.toArray(), index = items.indexOf(this.state.dropdownState.selectedItem);
		        if (!actions_1.ACTIONS.hasOwnProperty(key)) {
		            return;
		        }
		        actions_1.ACTIONS[key].call(this, index, items, this.state.dropdownState);
		        $event.preventDefault();
		        $event.stopPropagation();
		    };
		    Ng2DropdownMenu.prototype.getMenuElement = function () {
		        return this.element.nativeElement.children[0];
		    };
		    Ng2DropdownMenu.prototype.calcPositionOffset = function (position) {
		        if (!position) {
		            return;
		        }
		        var supportPageOffset = window.pageXOffset !== undefined;
		        var isCSS1Compat = ((document.compatMode || '') === 'CSS1Compat');
		        var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ?
		            document.documentElement.scrollLeft : document.body.scrollLeft;
		        var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ?
		            document.documentElement.scrollTop : document.body.scrollTop;
		        var _a = this.applyOffset((position.top + y - 15) + "px", (position.left + x - 5) + "px"), top = _a.top, left = _a.left;
		        var element = this.getMenuElement(), clientWidth = element.clientWidth, clientHeight = element.clientHeight, marginFromBottom = parseInt(top) + clientHeight, marginFromRight = parseInt(left) + clientWidth, windowScrollHeight = window.innerHeight + window.scrollY, windowScrollWidth = window.innerWidth + window.scrollX;
		        if (marginFromBottom >= windowScrollHeight) {
		            top = (parseInt(top.replace('px', '')) - clientHeight) + "px";
		        }
		        if (marginFromRight >= windowScrollWidth) {
		            var marginRight = marginFromRight - windowScrollWidth + 30;
		            left = (parseInt(left.replace('px', '')) - marginRight) + "px";
		        }
		        return { top: top, left: left };
		    };
		    Ng2DropdownMenu.prototype.applyOffset = function (top, left) {
		        if (!this.offset) {
		            return { top: top, left: left };
		        }
		        var offset = this.offset.split(' ');
		        if (!offset[1]) {
		            offset[1] = '0';
		        }
		        top = (parseInt(top.replace('px', '')) + parseInt(offset[0])) + "px";
		        left = (parseInt(left.replace('px', '')) + parseInt(offset[1])) + "px";
		        return { top: top, left: left };
		    };
		    Ng2DropdownMenu.prototype.ngOnInit = function () {
		        var body = document.querySelector('body');
		        body.appendChild(this.element.nativeElement);
		        this.listener = this.renderer.listen(body, 'keyup', this.handleKeypress.bind(this));
		    };
		    Ng2DropdownMenu.prototype.ngDoCheck = function () {
		        if (this.state.menuState.isVisible && this.position) {
		            var element = this.getMenuElement();
		            var position = this.calcPositionOffset(this.position);
		            if (position) {
		                this.renderer.setElementStyle(element, 'top', position.top);
		                this.renderer.setElementStyle(element, 'left', position.left);
		            }
		        }
		    };
		    Ng2DropdownMenu.prototype.ngOnDestroy = function () {
		        var elem = this.element.nativeElement;
		        elem.parentNode.removeChild(elem);
		        if (this.listener) {
		            this.listener();
		        }
		    };
		    __decorate([
		        core_1.Input(), 
		        __metadata('design:type', Number)
		    ], Ng2DropdownMenu.prototype, "width", void 0);
		    __decorate([
		        core_1.Input(), 
		        __metadata('design:type', Boolean)
		    ], Ng2DropdownMenu.prototype, "focusFirstElement", void 0);
		    __decorate([
		        core_1.Input(), 
		        __metadata('design:type', String)
		    ], Ng2DropdownMenu.prototype, "offset", void 0);
		    __decorate([
		        core_1.ContentChildren(ng2_menu_item_1.Ng2MenuItem), 
		        __metadata('design:type', core_1.QueryList)
		    ], Ng2DropdownMenu.prototype, "items", void 0);
		    Ng2DropdownMenu = __decorate([
		        core_1.Component({
		            selector: 'ng2-dropdown-menu',
		            styles: [__webpack_require__(14)],
		            template: __webpack_require__(15),
		            animations: [
		                core_1.trigger('fade', [
		                    core_1.state('visible', core_1.style({
		                        maxHeight: '400px',
		                        opacity: 1
		                    })),
		                    core_1.state('hidden', core_1.style({
		                        maxHeight: '0',
		                        opacity: 0
		                    })),
		                    core_1.transition('visible => hidden', [
		                        core_1.animate('250ms ease-out')
		                    ]),
		                    core_1.transition('hidden => visible', [
		                        core_1.animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')
		                    ])
		                ])
		            ]
		        }), 
		        __metadata('design:paramtypes', [dropdown_state_service_1.DropdownStateService, core_1.ElementRef, core_1.Renderer])
		    ], Ng2DropdownMenu);
		    return Ng2DropdownMenu;
		}());
		exports.Ng2DropdownMenu = Ng2DropdownMenu;
		

	/***/ },
	/* 8 */
	/***/ function(module, exports) {

		"use strict";
		var KEYS = {
		    BACKSPACE: 9,
		    PREV: 38,
		    NEXT: 40
		};
		var onSwitchNext = function (index, items, state) {
		    if (index < items.length - 1) {
		        state.select(items[index + 1], true);
		    }
		};
		var onSwitchPrev = function (index, items, state) {
		    if (index > 0) {
		        state.select(items[index - 1], true);
		    }
		};
		var onBackspace = function (index, items, state) {
		    if (index < items.length - 1) {
		        state.select(items[index + 1], true);
		    }
		    else {
		        state.select(items[0], true);
		    }
		};
		exports.ACTIONS = (_a = {},
		    _a[KEYS.BACKSPACE] = onBackspace,
		    _a[KEYS.PREV] = onSwitchPrev,
		    _a[KEYS.NEXT] = onSwitchNext,
		    _a
		);
		function arrowKeysHandler(event) {
		    if ([38, 40].indexOf(event.keyCode) > -1) {
		        event.preventDefault();
		    }
		}
		exports.arrowKeysHandler = arrowKeysHandler;
		var _a;


	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
		    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
		    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
		    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
		    return c > 3 && r && Object.defineProperty(target, key, r), r;
		};
		var __metadata = (this && this.__metadata) || function (k, v) {
		    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
		};
		var core_1 = __webpack_require__(3);
		var dropdown_state_service_1 = __webpack_require__(10);
		var Ng2MenuItem = (function () {
		    function Ng2MenuItem(state, element, renderer) {
		        this.state = state;
		        this.element = element;
		        this.renderer = renderer;
		        this.preventClose = false;
		    }
		    Object.defineProperty(Ng2MenuItem.prototype, "isSelected", {
		        get: function () {
		            return this === this.state.dropdownState.selectedItem;
		        },
		        enumerable: true,
		        configurable: true
		    });
		    Ng2MenuItem.prototype.select = function ($event) {
		        this.state.dropdownState.select(this, true);
		        if ($event) {
		            $event.stopPropagation();
		            $event.preventDefault();
		        }
		    };
		    Ng2MenuItem.prototype.click = function () {
		        this.state.dropdownState.onItemClicked.emit(this);
		    };
		    Ng2MenuItem.prototype.focus = function () {
		        this.renderer.invokeElementMethod(this.element.nativeElement.children[0], 'focus', []);
		    };
		    __decorate([
		        core_1.Input(), 
		        __metadata('design:type', Boolean)
		    ], Ng2MenuItem.prototype, "preventClose", void 0);
		    __decorate([
		        core_1.Input(), 
		        __metadata('design:type', Object)
		    ], Ng2MenuItem.prototype, "value", void 0);
		    Ng2MenuItem = __decorate([
		        core_1.Component({
		            selector: 'ng2-menu-item',
		            styles: [__webpack_require__(12)],
		            template: __webpack_require__(13)
		        }), 
		        __metadata('design:paramtypes', [dropdown_state_service_1.DropdownStateService, core_1.ElementRef, core_1.Renderer])
		    ], Ng2MenuItem);
		    return Ng2MenuItem;
		}());
		exports.Ng2MenuItem = Ng2MenuItem;
		

	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
		    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
		    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
		    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
		    return c > 3 && r && Object.defineProperty(target, key, r), r;
		};
		var __metadata = (this && this.__metadata) || function (k, v) {
		    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
		};
		var core_1 = __webpack_require__(3);
		var ng2_dropdown_state_1 = __webpack_require__(11);
		var DropdownStateService = (function () {
		    function DropdownStateService() {
		        this.menuState = {
		            isVisible: false,
		            toString: function () {
		                return this.isVisible === true ? 'visible' : 'hidden';
		            }
		        };
		        this.dropdownState = new ng2_dropdown_state_1.Ng2DropdownState();
		    }
		    DropdownStateService = __decorate([
		        core_1.Injectable(), 
		        __metadata('design:paramtypes', [])
		    ], DropdownStateService);
		    return DropdownStateService;
		}());
		exports.DropdownStateService = DropdownStateService;
		

	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";
		var core_1 = __webpack_require__(3);
		var Ng2DropdownState = (function () {
		    function Ng2DropdownState() {
		        this.onItemSelected = new core_1.EventEmitter();
		        this.onItemClicked = new core_1.EventEmitter();
		    }
		    Object.defineProperty(Ng2DropdownState.prototype, "selectedItem", {
		        get: function () {
		            return this._selectedItem;
		        },
		        enumerable: true,
		        configurable: true
		    });
		    Ng2DropdownState.prototype.select = function (item, dispatchEvent) {
		        if (dispatchEvent === void 0) { dispatchEvent = true; }
		        this._selectedItem = item;
		        if (!dispatchEvent) {
		            return;
		        }
		        item.focus();
		        this.onItemSelected.emit(item);
		    };
		    Ng2DropdownState.prototype.unselect = function () {
		        this._selectedItem = undefined;
		    };
		    return Ng2DropdownState;
		}());
		exports.Ng2DropdownState = Ng2DropdownState;
		

	/***/ },
	/* 12 */
	/***/ function(module, exports) {

		module.exports = ".ng2-menu-item {\n  font-family: \"Roboto\", \"Helvetica Neue\", Helvetica, Arial;\n  padding: 0.3em 1.25rem;\n  background: #fff;\n  color: rgba(0, 0, 0, 0.87);\n  cursor: pointer;\n  font-size: 0.9em;\n  text-transform: none;\n  font-weight: 400;\n  -webkit-transition: background 0.2s;\n  transition: background 0.2s;\n  letter-spacing: 0.03em;\n  height: 48px;\n  line-height: 48px;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow-x: hidden; }\n\n.ng2-menu-item--selected {\n  background: rgba(158, 158, 158, 0.2);\n  outline: 0; }\n\n.ng2-menu-item:focus {\n  outline: 0; }\n\n.ng2-menu-item:active {\n  background: rgba(158, 158, 158, 0.4); }\n\n:host(ng2-menu-item) /deep/ [ng2-menu-item-icon] {\n  vertical-align: middle;\n  font-size: 28px;\n  width: 1.5em;\n  height: 30px;\n  color: rgba(0, 0, 0, 0.44); }\n"

	/***/ },
	/* 13 */
	/***/ function(module, exports) {

		module.exports = "<div class='ng2-menu-item'\n     [attr.tabindex]=\"0\"\n     [class.ng2-menu-item--selected]=\"isSelected\"\n     [attr.role]=\"button\"\n     (keydown.enter)=\"click()\"\n     (click)=\"click()\"\n     (mouseover)=\"select()\">\n        <ng-content></ng-content>\n</div>\n";

	/***/ },
	/* 14 */
	/***/ function(module, exports) {

		module.exports = ".ng2-dropdown-menu-container {\n  position: absolute;\n  z-index: 100;\n  overflow-y: auto;\n  visibility: hidden;\n  box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.3);\n  width: 0;\n  -webkit-transition: width 0.5s;\n  transition: width 0.5s;\n  background: #fff; }\n\n.ng2-dropdown-menu-container--open {\n  visibility: visible; }\n\n.ng2-dropdown-menu-container--2 {\n  width: 180px; }\n\n.ng2-dropdown-menu-container--4 {\n  width: 250px; }\n\n.ng2-dropdown-menu-container--6 {\n  width: 320px; }\n\n.ng2-dropdown-menu-container:focus {\n  outline: 0;\n  box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.3); }\n\n.ng2-dropdown-menu {\n  position: relative;\n  padding: 0.5em 0;\n  background: #fff;\n  border-radius: 2px;\n  max-height: 400px;\n  display: block; }\n\n.ng2-dropdown-menu * {\n  opacity: 0;\n  -webkit-transition: opacity 0.5s;\n  transition: opacity 0.5s; }\n\n.ng2-dropdown-menu-container.ng2-dropdown-menu-container--open * {\n  opacity: 1; }\n\n.ng2-dropdown-backdrop {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 1; }\n\n:host /deep/ .ng2-menu-divider {\n  height: 1px;\n  min-height: 1px;\n  max-height: 1px;\n  width: 100%;\n  display: block;\n  background: #f9f9f9; }\n"

	/***/ },
	/* 15 */
	/***/ function(module, exports) {

		module.exports = "<!-- CONTAINER -->\n<div class=\"ng2-dropdown-menu-container ng2-dropdown-menu-container--{{ width }}\"\n     [class.ng2-dropdown-menu-container--open]=\"state.menuState.isVisible\"\n     [@fade]=\"state.menuState.toString()\"\n     tabindex=\"-1\">\n\n    <!-- MENU -->\n    <div class='ng2-dropdown-menu'>\n        <ng-content></ng-content>\n    </div>\n</div>\n\n<!-- BACKDROP -->\n<div class=\"ng2-dropdown-backdrop\" *ngIf=\"state.menuState.isVisible\" (click)=\"hide()\"></div>\n";

	/***/ },
	/* 16 */
	/***/ function(module, exports) {

		module.exports = ""

	/***/ },
	/* 17 */
	/***/ function(module, exports) {

		module.exports = "<div class=\"ng2-dropdown-container\">\n    <ng-content select=\"ng2-dropdown-button\"></ng-content>\n    <ng-content select=\"ng2-dropdown-menu\"></ng-content>\n</div>\n";

	/***/ },
	/* 18 */
	/***/ function(module, exports) {

		module.exports = __WEBPACK_EXTERNAL_MODULE_18__;

	/***/ }
	/******/ ])
	});
	;


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(6));
	

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(1);
	var DeleteIconComponent = (function () {
	    function DeleteIconComponent() {
	    }
	    DeleteIconComponent = __decorate([
	        core_1.Component({
	            selector: 'delete-icon',
	            template: __webpack_require__(7),
	            styles: [__webpack_require__(8)]
	        }), 
	        __metadata('design:paramtypes', [])
	    ], DeleteIconComponent);
	    return DeleteIconComponent;
	}());
	exports.DeleteIconComponent = DeleteIconComponent;
	

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = "<span>\n    <svg enable-background=\"new 0 0 32 32\" height=\"16px\" version=\"1.1\" viewBox=\"0 0 32 32\" width=\"16px\" xml:space=\"preserve\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><path d=\"M17.459,16.014l8.239-8.194c0.395-0.391,0.395-1.024,0-1.414c-0.394-0.391-1.034-0.391-1.428,0  l-8.232,8.187L7.73,6.284c-0.394-0.395-1.034-0.395-1.428,0c-0.394,0.396-0.394,1.037,0,1.432l8.302,8.303l-8.332,8.286  c-0.394,0.391-0.394,1.024,0,1.414c0.394,0.391,1.034,0.391,1.428,0l8.325-8.279l8.275,8.276c0.394,0.395,1.034,0.395,1.428,0  c0.394-0.396,0.394-1.037,0-1.432L17.459,16.014z\" fill=\"#121313\" /><g/><g/><g/><g/><g/><g/></svg>\n</span>\n";

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = ":host(delete-icon) {\n  width: 16px;\n  height: 26px;\n  -webkit-transition: all 0.15s;\n  transition: all 0.15s;\n  display: inline-block; }\n\n:host(delete-icon):hover {\n  -webkit-transform: scale(1.3);\n          transform: scale(1.3); }\n\n:host(delete-icon) svg {\n  vertical-align: bottom;\n  height: 34px; }\n\n:host-context(.default) path {\n  fill: #444; }\n\n:host-context(.dark) path {\n  fill: #fff; }\n\n:host-context(.minimal) path {\n  fill: #444; }\n\n:host-context(.default tag:focus) path, :host-context(.default tag:active) path {\n  fill: #fff; }\n\n:host-context(.dark tag:focus) path, :host-context(.dark tag:active) path {\n  fill: #000; }\n\n:host-context(.minimal tag:focus) path, :host-context(.minimal tag:active) path {\n  fill: #000; }\n"

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(10));
	

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(1);
	var forms_1 = __webpack_require__(2);
	var TagInputForm = (function () {
	    function TagInputForm(renderer) {
	        this.renderer = renderer;
	        this.onSubmit = new core_1.EventEmitter();
	        this.onBlur = new core_1.EventEmitter();
	        this.onFocus = new core_1.EventEmitter();
	        this.onKeyup = new core_1.EventEmitter();
	        this.onKeydown = new core_1.EventEmitter();
	        this.validators = [];
	    }
	    TagInputForm.prototype.ngOnInit = function () {
	        this.form = new forms_1.FormGroup({
	            item: new forms_1.FormControl('', forms_1.Validators.compose(this.validators))
	        });
	    };
	    Object.defineProperty(TagInputForm.prototype, "value", {
	        get: function () {
	            return this.form.get('item');
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TagInputForm.prototype.isInputFocused = function () {
	        return document.activeElement === this.input.nativeElement;
	    };
	    TagInputForm.prototype.getErrorMessages = function (messages) {
	        var _this = this;
	        return Object.keys(messages)
	            .filter(function (err) { return _this.value.hasError(err); })
	            .map(function (err) { return messages[err]; });
	    };
	    TagInputForm.prototype.hasErrors = function () {
	        return this.form.dirty && this.form.value.item && this.form.invalid;
	    };
	    TagInputForm.prototype.focus = function () {
	        this.renderer.invokeElementMethod(this.input.nativeElement, 'focus');
	    };
	    TagInputForm.prototype.getElementPosition = function () {
	        return this.input.nativeElement.getBoundingClientRect();
	    };
	    TagInputForm.prototype.destroy = function () {
	        var input = this.input.nativeElement;
	        input.parentElement.removeChild(input);
	    };
	    TagInputForm.prototype.onKeyDown = function ($event) {
	        return this.onKeydown.emit($event);
	    };
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], TagInputForm.prototype, "onSubmit", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], TagInputForm.prototype, "onBlur", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], TagInputForm.prototype, "onFocus", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], TagInputForm.prototype, "onKeyup", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], TagInputForm.prototype, "onKeydown", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagInputForm.prototype, "placeholder", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Array)
	    ], TagInputForm.prototype, "validators", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagInputForm.prototype, "inputId", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagInputForm.prototype, "inputClass", void 0);
	    __decorate([
	        core_1.ViewChild('input'), 
	        __metadata('design:type', Object)
	    ], TagInputForm.prototype, "input", void 0);
	    TagInputForm = __decorate([
	        core_1.Component({
	            selector: 'tag-input-form',
	            styles: [__webpack_require__(11)],
	            template: __webpack_require__(12)
	        }), 
	        __metadata('design:paramtypes', [core_1.Renderer])
	    ], TagInputForm);
	    return TagInputForm;
	}());
	exports.TagInputForm = TagInputForm;
	

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = ".ng2-tag-input__text-input {\n  border: none;\n  display: inline;\n  padding: 0 0.5rem;\n  vertical-align: middle;\n  font-size: 1em;\n  height: 38px;\n  font-family: \"Roboto\", \"Helvetica Neue\", sans-serif; }\n\n.ng2-tag-input__text-input:focus {\n  outline: 0; }\n"

/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = "<!-- form -->\n<form (submit)=\"onSubmit.emit()\" [formGroup]=\"form\">\n    <input #input\n           type=\"text\"\n           required\n           class=\"ng2-tag-input__text-input\"\n           formControlName=\"item\"\n           tabindex=\"0\"\n\n           [ngClass]=\"inputClass\"\n           [attr.id]=\"inputId\"\n           [attr.placeholder]=\"placeholder\"\n           [attr.aria-label]=\"placeholder\"\n\n           (focus)=\"onFocus.emit($event)\"\n           (blur)=\"onBlur.emit($event)\"\n           (keydown)=\"onKeyDown($event)\"\n           (keyup)=\"onKeyup.emit($event)\"\n    />\n</form>\n";

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(14));
	

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(1);
	var forms_1 = __webpack_require__(2);
	var constants = __webpack_require__(15);
	var listen_1 = __webpack_require__(16);
	var accessor_1 = __webpack_require__(17);
	var tag_input_form_component_1 = __webpack_require__(10);
	var tag_input_dropdown_component_1 = __webpack_require__(18);
	var tag_component_1 = __webpack_require__(38);
	__webpack_require__(42);
	var TagInputComponent = (function (_super) {
	    __extends(TagInputComponent, _super);
	    function TagInputComponent(renderer) {
	        _super.call(this);
	        this.renderer = renderer;
	        this.separatorKeys = [];
	        this.placeholder = constants.PLACEHOLDER;
	        this.secondaryPlaceholder = constants.SECONDARY_PLACEHOLDER;
	        this.maxItems = undefined;
	        this.readonly = undefined;
	        this.transform = function (item) { return item; };
	        this.validators = [];
	        this.onlyFromAutocomplete = false;
	        this.errorMessages = {};
	        this.theme = 'default';
	        this.onTextChangeDebounce = 250;
	        this.pasteSplitPattern = ',';
	        this.blinkIfDupe = true;
	        this.removable = true;
	        this.editable = false;
	        this.allowDupes = false;
	        this.onAdd = new core_1.EventEmitter();
	        this.onRemove = new core_1.EventEmitter();
	        this.onSelect = new core_1.EventEmitter();
	        this.onFocus = new core_1.EventEmitter();
	        this.onBlur = new core_1.EventEmitter();
	        this.onTextChange = new core_1.EventEmitter();
	        this.onPaste = new core_1.EventEmitter();
	        this.onValidationError = new core_1.EventEmitter();
	        this.onTagEdited = new core_1.EventEmitter();
	        this.listeners = (_a = {},
	            _a[constants.KEYDOWN] = [],
	            _a[constants.KEYUP] = [],
	            _a.change = [],
	            _a
	        );
	        this.isLoading = false;
	        var _a;
	    }
	    TagInputComponent.prototype.removeItem = function (tag, index) {
	        this.items = this.getItemsWithout(index);
	        if (this.selectedTag === tag) {
	            this.selectedTag = undefined;
	        }
	        this.focus(true);
	        this.onRemove.emit(tag);
	    };
	    TagInputComponent.prototype.addItem = function (isFromAutocomplete) {
	        if (isFromAutocomplete === void 0) { isFromAutocomplete = false; }
	        var inputValue = this.setInputValue(this.inputForm.value.value);
	        var tag = this.createTag(inputValue, inputValue);
	        if (!this.inputForm.form.valid) {
	            return;
	        }
	        if (this.isTagValid(tag, isFromAutocomplete)) {
	            this.appendNewTag(tag);
	        }
	        else {
	            this.onValidationError.emit(tag);
	        }
	        this.setInputValue('');
	        this.focus(true);
	    };
	    TagInputComponent.prototype.isTagValid = function (tag, isFromAutocomplete) {
	        var _this = this;
	        if (isFromAutocomplete === void 0) { isFromAutocomplete = false; }
	        var selectedItem = this.dropdown ? this.dropdown.selectedItem : undefined;
	        if (selectedItem && !isFromAutocomplete) {
	            return;
	        }
	        var displayBy = this.displayBy;
	        var identifyBy = this.identifyBy;
	        var dupe = this.items.find(function (item) {
	            return item === tag[identifyBy] ||
	                item[identifyBy] === tag[identifyBy] ||
	                item[displayBy] === tag[displayBy];
	        });
	        if (!this.allowDupes && !!dupe && this.blinkIfDupe) {
	            var item = this.tags.find(function (item) { return _this.getItemValue(item.model) === _this.getItemValue(dupe); });
	            item.blink();
	        }
	        var fromAutocomplete = isFromAutocomplete && this.onlyFromAutocomplete;
	        return (dupe === undefined || this.allowDupes === true) &&
	            this.maxItemsReached === false &&
	            ((fromAutocomplete) || this.onlyFromAutocomplete === false);
	    };
	    TagInputComponent.prototype.appendNewTag = function (tag) {
	        this.items = this.items.concat([tag]);
	        this.onAdd.emit(tag);
	    };
	    TagInputComponent.prototype.createTag = function (display, value) {
	        return (_a = {},
	            _a[this.displayBy] = display,
	            _a[this.identifyBy] = value,
	            _a
	        );
	        var _a;
	    };
	    TagInputComponent.prototype.selectItem = function (item) {
	        if (this.readonly || !item || item === this.selectedTag) {
	            return;
	        }
	        this.selectedTag = item;
	        this.onSelect.emit(item);
	    };
	    TagInputComponent.prototype.fireEvents = function (eventName, $event) {
	        var _this = this;
	        this.listeners[eventName].forEach(function (listener) { return listener.call(_this, $event); });
	    };
	    TagInputComponent.prototype.handleKeydown = function (data) {
	        var event = data.event;
	        var key = event.keyCode || event.which;
	        switch (constants.KEY_PRESS_ACTIONS[key]) {
	            case constants.ACTIONS_KEYS.DELETE:
	                if (this.selectedTag && this.removable) {
	                    this.removeItem(this.selectedTag, this.items.indexOf(this.selectedTag));
	                }
	                break;
	            case constants.ACTIONS_KEYS.SWITCH_PREV:
	                this.switchPrev(data.model);
	                break;
	            case constants.ACTIONS_KEYS.SWITCH_NEXT:
	                this.switchNext(data.model);
	                break;
	            case constants.ACTIONS_KEYS.TAB:
	                this.switchNext(data.model);
	                break;
	            default:
	                return;
	        }
	        event.preventDefault();
	    };
	    TagInputComponent.prototype.setInputValue = function (value) {
	        var item = value ? this.transform(value) : '';
	        var control = this.getControl();
	        control.setValue(item);
	        return item;
	    };
	    TagInputComponent.prototype.getControl = function () {
	        return this.inputForm.value;
	    };
	    TagInputComponent.prototype.focus = function (applyFocus) {
	        if (applyFocus === void 0) { applyFocus = false; }
	        if (this.readonly) {
	            return;
	        }
	        if (this.dropdown) {
	            this.dropdown.show();
	        }
	        this.selectedTag = undefined;
	        this.onFocus.emit(this.inputForm.value.value);
	        if (applyFocus) {
	            this.inputForm.focus();
	        }
	    };
	    TagInputComponent.prototype.blur = function () {
	        this.onBlur.emit(this.inputForm.value.value);
	    };
	    TagInputComponent.prototype.hasErrors = function () {
	        return this.inputForm && this.inputForm.hasErrors() ? true : false;
	    };
	    TagInputComponent.prototype.isInputFocused = function () {
	        return this.inputForm && this.inputForm.isInputFocused() ? true : false;
	    };
	    TagInputComponent.prototype.hasCustomTemplate = function () {
	        var template = this.templates ? this.templates.first : undefined;
	        var menuTemplate = this.dropdown && this.dropdown.templates ? this.dropdown.templates.first : undefined;
	        return template && template !== menuTemplate;
	    };
	    TagInputComponent.prototype.switchNext = function (item) {
	        if (this.tags.last.model === item) {
	            this.focus(true);
	            return;
	        }
	        var tags = this.tags.toArray();
	        var tagIndex = tags.findIndex(function (tag) { return tag.model === item; });
	        var tag = tags[tagIndex + 1];
	        tag.select.call(tag);
	    };
	    TagInputComponent.prototype.switchPrev = function (item) {
	        if (this.tags.first.model !== item) {
	            var tags = this.tags.toArray();
	            var tagIndex = tags.findIndex(function (tag) { return tag.model === item; });
	            var tag = tags[tagIndex - 1];
	            tag.select.call(tag);
	        }
	    };
	    Object.defineProperty(TagInputComponent.prototype, "maxItemsReached", {
	        get: function () {
	            return this.maxItems !== undefined && this.items.length >= this.maxItems;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TagInputComponent.prototype.trackBy = function (item) {
	        return item[this.identifyBy];
	    };
	    TagInputComponent.prototype.onPasteCallback = function (data) {
	        var _this = this;
	        var text = data.clipboardData.getData('text/plain');
	        text.split(this.pasteSplitPattern)
	            .map(function (item) { return _this.createTag(item, item); })
	            .forEach(function (item) {
	            var display = _this.transform(item[_this.displayBy]);
	            var tag = _this.createTag(display, display);
	            if (_this.isTagValid(tag)) {
	                _this.appendNewTag(tag);
	            }
	        });
	        this.onPaste.emit(text);
	        setTimeout(function () { return _this.setInputValue(''); }, 0);
	    };
	    TagInputComponent.prototype.ngOnInit = function () {
	        var _this = this;
	        listen_1.default.call(this, constants.KEYDOWN, function ($event) {
	            var itemsLength = _this.items.length, inputValue = _this.inputForm.value.value, isCorrectKey = $event.keyCode === 37 || $event.keyCode === 8;
	            if (isCorrectKey && !inputValue && itemsLength) {
	                _this.tags.last.select.call(_this.tags.last);
	            }
	        });
	        listen_1.default.call(this, constants.KEYDOWN, function ($event) {
	            if (_this.separatorKeys.indexOf($event.keyCode) >= 0) {
	                $event.preventDefault();
	                _this.addItem();
	            }
	        }, this.separatorKeys.length > 0);
	        var maxItemsReached = this.maxItems !== undefined && this.items && this.items.length > this.maxItems;
	        if (maxItemsReached) {
	            this.maxItems = this.items.length;
	            console.warn(constants.MAX_ITEMS_WARNING);
	        }
	    };
	    TagInputComponent.prototype.ngAfterViewInit = function () {
	        var _this = this;
	        this.inputForm.onKeydown.subscribe(function (event) {
	            _this.fireEvents('keydown', event);
	        });
	        if (this.onTextChange.observers.length) {
	            this.inputForm.form.valueChanges
	                .debounceTime(this.onTextChangeDebounce)
	                .subscribe(function () {
	                var value = _this.inputForm.value.value;
	                _this.onTextChange.emit(value);
	            });
	        }
	        if (this.clearOnBlur || this.addOnBlur) {
	            this.inputForm
	                .onBlur
	                .subscribe(function () {
	                if (_this.addOnBlur) {
	                    _this.addItem();
	                }
	                _this.setInputValue('');
	            });
	        }
	        if (this.addOnPaste) {
	            var input = this.inputForm.input.nativeElement;
	            this.renderer.listen(input, 'paste', this.onPasteCallback.bind(this));
	        }
	        if (this.hideForm) {
	            this.inputForm.destroy();
	        }
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Array)
	    ], TagInputComponent.prototype, "separatorKeys", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagInputComponent.prototype, "placeholder", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagInputComponent.prototype, "secondaryPlaceholder", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Number)
	    ], TagInputComponent.prototype, "maxItems", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Boolean)
	    ], TagInputComponent.prototype, "readonly", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Function)
	    ], TagInputComponent.prototype, "transform", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], TagInputComponent.prototype, "validators", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Boolean)
	    ], TagInputComponent.prototype, "onlyFromAutocomplete", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], TagInputComponent.prototype, "errorMessages", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagInputComponent.prototype, "theme", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Number)
	    ], TagInputComponent.prototype, "onTextChangeDebounce", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagInputComponent.prototype, "inputId", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagInputComponent.prototype, "inputClass", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagInputComponent.prototype, "clearOnBlur", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagInputComponent.prototype, "hideForm", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Boolean)
	    ], TagInputComponent.prototype, "addOnBlur", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Boolean)
	    ], TagInputComponent.prototype, "addOnPaste", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagInputComponent.prototype, "pasteSplitPattern", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Boolean)
	    ], TagInputComponent.prototype, "blinkIfDupe", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Boolean)
	    ], TagInputComponent.prototype, "removable", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Boolean)
	    ], TagInputComponent.prototype, "editable", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Boolean)
	    ], TagInputComponent.prototype, "allowDupes", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], TagInputComponent.prototype, "onAdd", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], TagInputComponent.prototype, "onRemove", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], TagInputComponent.prototype, "onSelect", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], TagInputComponent.prototype, "onFocus", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], TagInputComponent.prototype, "onBlur", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], TagInputComponent.prototype, "onTextChange", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], TagInputComponent.prototype, "onPaste", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], TagInputComponent.prototype, "onValidationError", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', Object)
	    ], TagInputComponent.prototype, "onTagEdited", void 0);
	    __decorate([
	        core_1.ContentChild(tag_input_dropdown_component_1.TagInputDropdown), 
	        __metadata('design:type', tag_input_dropdown_component_1.TagInputDropdown)
	    ], TagInputComponent.prototype, "dropdown", void 0);
	    __decorate([
	        core_1.ContentChildren(core_1.TemplateRef, { descendants: false }), 
	        __metadata('design:type', core_1.QueryList)
	    ], TagInputComponent.prototype, "templates", void 0);
	    __decorate([
	        core_1.ViewChild(tag_input_form_component_1.TagInputForm), 
	        __metadata('design:type', tag_input_form_component_1.TagInputForm)
	    ], TagInputComponent.prototype, "inputForm", void 0);
	    __decorate([
	        core_1.ViewChildren(tag_component_1.TagComponent), 
	        __metadata('design:type', core_1.QueryList)
	    ], TagInputComponent.prototype, "tags", void 0);
	    TagInputComponent = __decorate([
	        core_1.Component({
	            selector: 'tag-input',
	            providers: [{
	                    provide: forms_1.NG_VALUE_ACCESSOR,
	                    useExisting: core_1.forwardRef(function () { return TagInputComponent; }),
	                    multi: true
	                }],
	            styles: [__webpack_require__(49)],
	            template: __webpack_require__(50),
	            animations: [
	                core_1.trigger('flyInOut', [
	                    core_1.state('in', core_1.style({ transform: 'translateX(0)' })),
	                    core_1.transition(':enter', [
	                        core_1.animate(250, core_1.keyframes([
	                            core_1.style({ opacity: 0, offset: 0, transform: 'translate(0px, 20px)' }),
	                            core_1.style({ opacity: 0.3, offset: 0.3, transform: 'translate(0px, -10px)' }),
	                            core_1.style({ opacity: 0.5, offset: 0.5, transform: 'translate(0px, 0px)' }),
	                            core_1.style({ opacity: 0.75, offset: 0.75, transform: 'translate(0px, 5px)' }),
	                            core_1.style({ opacity: 1, offset: 1, transform: 'translate(0px, 0px)' })
	                        ]))
	                    ]),
	                    core_1.transition(':leave', [
	                        core_1.animate(150, core_1.keyframes([
	                            core_1.style({ opacity: 1, transform: 'translateX(0)', offset: 0 }),
	                            core_1.style({ opacity: 1, transform: 'translateX(-15px)', offset: 0.7 }),
	                            core_1.style({ opacity: 0, transform: 'translateX(100%)', offset: 1.0 })
	                        ]))
	                    ])
	                ])
	            ]
	        }), 
	        __metadata('design:paramtypes', [core_1.Renderer])
	    ], TagInputComponent);
	    return TagInputComponent;
	}(accessor_1.TagInputAccessor));
	exports.TagInputComponent = TagInputComponent;
	

/***/ },
/* 15 */
/***/ function(module, exports) {

	"use strict";
	exports.PLACEHOLDER = '+ Tag';
	exports.SECONDARY_PLACEHOLDER = 'Enter a new tag';
	exports.KEYDOWN = 'keydown';
	exports.KEYUP = 'keyup';
	exports.FOCUS = 'focus';
	exports.MAX_ITEMS_WARNING = 'The number of items specified was greater than the property max-items.';
	exports.ACTIONS_KEYS = {
	    DELETE: 'DELETE',
	    SWITCH_PREV: 'SWITCH_PREV',
	    SWITCH_NEXT: 'SWITCH_NEXT',
	    TAB: 'TAB'
	};
	exports.KEY_PRESS_ACTIONS = {
	    8: exports.ACTIONS_KEYS.DELETE,
	    37: exports.ACTIONS_KEYS.SWITCH_PREV,
	    39: exports.ACTIONS_KEYS.SWITCH_NEXT,
	    9: exports.ACTIONS_KEYS.TAB
	};
	

/***/ },
/* 16 */
/***/ function(module, exports) {

	"use strict";
	function listen(listenerType, action, condition) {
	    if (condition === void 0) { condition = true; }
	    if (!this.listeners.hasOwnProperty(listenerType)) {
	        throw new Error('The event entered may be wrong');
	    }
	    if (!condition) {
	        return;
	    }
	    this.listeners[listenerType].push(action);
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = listen;
	

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(1);
	function isObject(obj) {
	    return obj === Object(obj);
	}
	exports.isObject = isObject;
	var TagInputAccessor = (function () {
	    function TagInputAccessor() {
	        this._items = [];
	        this.displayBy = 'display';
	        this.identifyBy = 'value';
	    }
	    Object.defineProperty(TagInputAccessor.prototype, "items", {
	        get: function () {
	            return this._items;
	        },
	        set: function (items) {
	            this._items = items;
	            this._onChangeCallback(this._items);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    TagInputAccessor.prototype.onTouched = function (items) {
	        this._onTouchedCallback(items);
	    };
	    TagInputAccessor.prototype.writeValue = function (items) {
	        this._items = items || [];
	    };
	    TagInputAccessor.prototype.registerOnChange = function (fn) {
	        this._onChangeCallback = fn;
	    };
	    TagInputAccessor.prototype.registerOnTouched = function (fn) {
	        this._onTouchedCallback = fn;
	    };
	    TagInputAccessor.prototype.getItemValue = function (item) {
	        return isObject(item) ? item[this.identifyBy] : item;
	    };
	    TagInputAccessor.prototype.getItemsWithout = function (index) {
	        return this.items.filter(function (item, position) { return position !== index; });
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagInputAccessor.prototype, "displayBy", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagInputAccessor.prototype, "identifyBy", void 0);
	    return TagInputAccessor;
	}());
	exports.TagInputAccessor = TagInputAccessor;
	

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var core_1 = __webpack_require__(1);
	var tag_input_1 = __webpack_require__(14);
	var ng2_material_dropdown_1 = __webpack_require__(4);
	__webpack_require__(19);
	__webpack_require__(35);
	var TagInputDropdown = (function () {
	    function TagInputDropdown(tagInput) {
	        this.tagInput = tagInput;
	        this.offset = '50 0';
	        this.focusFirstElement = false;
	        this.showDropdownIfEmpty = false;
	        this.items = [];
	        this._autocompleteItems = [];
	    }
	    Object.defineProperty(TagInputDropdown.prototype, "autocompleteItems", {
	        get: function () {
	            return this._autocompleteItems;
	        },
	        set: function (items) {
	            this._autocompleteItems = items ? items.map(function (item) {
	                if (typeof item === 'string') {
	                    return { display: item, value: item };
	                }
	                else {
	                    return item;
	                }
	            }) : [];
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TagInputDropdown.prototype.ngOnInit = function () {
	        var _this = this;
	        this.onItemClicked().subscribe(function (item) {
	            _this.addNewItem(item);
	        });
	        this.onHide().subscribe(function () {
	            _this.resetItems();
	        });
	        this.tagInput.inputForm.onKeyup.subscribe(function () {
	            _this.show();
	        });
	        if (this.autocompleteObservable) {
	            this.tagInput
	                .onTextChange
	                .filter(function (text) { return !!text.trim().length; })
	                .subscribe(this.getItemsFromObservable.bind(this));
	        }
	    };
	    TagInputDropdown.prototype.updatePosition = function (position) {
	        return this.dropdown.menu.updatePosition(position);
	    };
	    Object.defineProperty(TagInputDropdown.prototype, "isVisible", {
	        get: function () {
	            return this.dropdown.menu.state.menuState.isVisible;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TagInputDropdown.prototype.onHide = function () {
	        return this.dropdown.onHide;
	    };
	    TagInputDropdown.prototype.onItemClicked = function () {
	        return this.dropdown.onItemClicked;
	    };
	    Object.defineProperty(TagInputDropdown.prototype, "selectedItem", {
	        get: function () {
	            return this.dropdown.menu.state.dropdownState.selectedItem;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TagInputDropdown.prototype, "state", {
	        get: function () {
	            return this.dropdown.menu.state;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TagInputDropdown.prototype.addNewItem = function (item) {
	        var _this = this;
	        if (!item) {
	            return;
	        }
	        if (this.tagInput.isTagValid(item.value, true)) {
	            this.tagInput.appendNewTag(item.value);
	        }
	        this.tagInput.setInputValue('');
	        setTimeout(function () { return _this.tagInput.inputForm.focus(); }, 0);
	        this.dropdown.hide();
	    };
	    TagInputDropdown.prototype.show = function () {
	        var value = this.tagInput.inputForm.value.value;
	        var position = this.tagInput.inputForm.getElementPosition();
	        var items = this.getMatchingItems(value);
	        var hasItems = items.length > 0;
	        var showDropdownIfEmpty = this.showDropdownIfEmpty && !value && hasItems;
	        this.items = items;
	        if ((hasItems || showDropdownIfEmpty) && !this.isVisible) {
	            this.dropdown.toggleMenu(position);
	        }
	        else if (!hasItems && this.isVisible) {
	            this.dropdown.hide();
	        }
	    };
	    TagInputDropdown.prototype.getMatchingItems = function (value) {
	        var _this = this;
	        if (!value && !this.showDropdownIfEmpty) {
	            return [];
	        }
	        var matchesFn = function (item) {
	            return item && item.toString()
	                .toLowerCase()
	                .indexOf(value.toLowerCase()) >= 0 || false;
	        };
	        var matchesValue = function (item) {
	            return typeof item === 'string' ?
	                matchesFn(item) :
	                matchesFn(item[_this.tagInput.displayBy]) || matchesFn(item[_this.tagInput.identifyBy]);
	        };
	        return this.autocompleteItems.filter(function (item) {
	            var hasValue = !!_this.tagInput.tags.find(function (tag) { return tag.model === item; });
	            return (matchesValue(item) === true) && (hasValue === false);
	        });
	    };
	    TagInputDropdown.prototype.resetItems = function () {
	        this.items = [];
	    };
	    TagInputDropdown.prototype.scrollListener = function () {
	        if (!this.isVisible) {
	            return;
	        }
	        this.updatePosition(this.tagInput.inputForm.getElementPosition());
	    };
	    TagInputDropdown.prototype.populateItems = function (data) {
	        var terms = data.map(function (item) { return ({ display: item, value: item }); });
	        this.autocompleteItems = this.autocompleteItems.concat(terms);
	        this.show();
	    };
	    TagInputDropdown.prototype.getItemsFromObservable = function (text) {
	        var _this = this;
	        this.tagInput.isLoading = true;
	        this.autocompleteObservable(text)
	            .subscribe(function (data) {
	            _this.tagInput.isLoading = false;
	            _this.populateItems(data);
	        });
	    };
	    __decorate([
	        core_1.ViewChild(ng2_material_dropdown_1.Ng2Dropdown), 
	        __metadata('design:type', ng2_material_dropdown_1.Ng2Dropdown)
	    ], TagInputDropdown.prototype, "dropdown", void 0);
	    __decorate([
	        core_1.ContentChildren(core_1.TemplateRef), 
	        __metadata('design:type', core_1.QueryList)
	    ], TagInputDropdown.prototype, "templates", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagInputDropdown.prototype, "offset", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Boolean)
	    ], TagInputDropdown.prototype, "focusFirstElement", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Array), 
	        __metadata('design:paramtypes', [Array])
	    ], TagInputDropdown.prototype, "autocompleteItems", null);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Boolean)
	    ], TagInputDropdown.prototype, "showDropdownIfEmpty", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Function)
	    ], TagInputDropdown.prototype, "autocompleteObservable", void 0);
	    __decorate([
	        core_1.HostListener('window:scroll'), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', []), 
	        __metadata('design:returntype', void 0)
	    ], TagInputDropdown.prototype, "scrollListener", null);
	    TagInputDropdown = __decorate([
	        core_1.Component({
	            selector: 'tag-input-dropdown',
	            template: __webpack_require__(37)
	        }),
	        __param(0, core_1.Inject(core_1.forwardRef(function () { return tag_input_1.TagInputComponent; }))), 
	        __metadata('design:paramtypes', [tag_input_1.TagInputComponent])
	    ], TagInputDropdown);
	    return TagInputDropdown;
	}());
	exports.TagInputDropdown = TagInputDropdown;
	

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(20);
	var map_1 = __webpack_require__(34);
	Observable_1.Observable.prototype.map = map_1.map;
	//# sourceMappingURL=map.js.map

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(21);
	var toSubscriber_1 = __webpack_require__(22);
	var observable_1 = __webpack_require__(33);
	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is  called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        if (operator) {
	            operator.call(sink, this.source);
	        }
	        else {
	            sink.add(this._subscribe(sink));
	        }
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            var subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1.$$observable] = function () {
	        return this;
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;
	//# sourceMappingURL=Observable.js.map

/***/ },
/* 21 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	/**
	 * window: browser in DOM main thread
	 * self: browser in WebWorker
	 * global: Node.js/other
	 */
	exports.root = (typeof window == 'object' && window.window === window && window
	    || typeof self == 'object' && self.self === self && self
	    || typeof global == 'object' && global.global === global && global);
	if (!exports.root) {
	    throw new Error('RxJS could not find any global context (window, self, global)');
	}
	//# sourceMappingURL=root.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(23);
	var rxSubscriber_1 = __webpack_require__(32);
	var Observer_1 = __webpack_require__(31);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
	            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber_1.Subscriber(Observer_1.empty);
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;
	//# sourceMappingURL=toSubscriber.js.map

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(24);
	var Subscription_1 = __webpack_require__(25);
	var Observer_1 = __webpack_require__(31);
	var rxSubscriber_1 = __webpack_require__(32);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        this.destination = destinationOrNext;
	                        this.destination.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parent, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parent = _parent;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            context = observerOrNext;
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (isFunction_1.isFunction(context.unsubscribe)) {
	                this.add(context.unsubscribe.bind(context));
	            }
	            context.unsubscribe = this.unsubscribe.bind(this);
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parent = this._parent;
	            if (!_parent.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parent, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._error) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parent.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parent.syncErrorValue = err;
	                _parent.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._complete) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._complete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._complete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parent = this._parent;
	        this._context = null;
	        this._parent = null;
	        _parent.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));
	//# sourceMappingURL=Subscriber.js.map

/***/ },
/* 24 */
/***/ function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;
	//# sourceMappingURL=isFunction.js.map

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(26);
	var isObject_1 = __webpack_require__(27);
	var isFunction_1 = __webpack_require__(24);
	var tryCatch_1 = __webpack_require__(28);
	var errorObject_1 = __webpack_require__(29);
	var UnsubscriptionError_1 = __webpack_require__(30);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.closed = false;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.closed) {
	            return;
	        }
	        this.closed = true;
	        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this._subscriptions = null;
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                (errors = errors || []).push(errorObject_1.errorObject.e);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            var index = -1;
	            var len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(err.errors);
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `closed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === Subscription.EMPTY)) {
	            return Subscription.EMPTY;
	        }
	        if (teardown === this) {
	            return this;
	        }
	        var sub = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                sub = new Subscription(teardown);
	            case 'object':
	                if (sub.closed || typeof sub.unsubscribe !== 'function') {
	                    break;
	                }
	                else if (this.closed) {
	                    sub.unsubscribe();
	                }
	                else {
	                    (this._subscriptions || (this._subscriptions = [])).push(sub);
	                }
	                break;
	            default:
	                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        return sub;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        // HACK: This might be redundant because of the logic in `add()`
	        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
	            return;
	        }
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.closed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	//# sourceMappingURL=Subscription.js.map

/***/ },
/* 26 */
/***/ function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArray.js.map

/***/ },
/* 27 */
/***/ function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;
	//# sourceMappingURL=isObject.js.map

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(29);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;
	//# sourceMappingURL=tryCatch.js.map

/***/ },
/* 29 */
/***/ function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };
	//# sourceMappingURL=errorObject.js.map

/***/ },
/* 30 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        var err = Error.call(this, errors ?
	            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
	        this.name = err.name = 'UnsubscriptionError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;
	//# sourceMappingURL=UnsubscriptionError.js.map

/***/ },
/* 31 */
/***/ function(module, exports) {

	"use strict";
	exports.empty = {
	    closed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};
	//# sourceMappingURL=Observer.js.map

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(21);
	var Symbol = root_1.root.Symbol;
	exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	//# sourceMappingURL=rxSubscriber.js.map

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(21);
	function getSymbolObservable(context) {
	    var $$observable;
	    var Symbol = context.Symbol;
	    if (typeof Symbol === 'function') {
	        if (Symbol.observable) {
	            $$observable = Symbol.observable;
	        }
	        else {
	            $$observable = Symbol('observable');
	            Symbol.observable = $$observable;
	        }
	    }
	    else {
	        $$observable = '@@observable';
	    }
	    return $$observable;
	}
	exports.getSymbolObservable = getSymbolObservable;
	exports.$$observable = getSymbolObservable(root_1.root);
	//# sourceMappingURL=observable.js.map

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(23);
	/**
	 * Applies a given `project` function to each value emitted by the source
	 * Observable, and emits the resulting values as an Observable.
	 *
	 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
	 * it passes each source value through a transformation function to get
	 * corresponding output values.</span>
	 *
	 * <img src="./img/map.png" width="100%">
	 *
	 * Similar to the well known `Array.prototype.map` function, this operator
	 * applies a projection to each value and emits that projection in the output
	 * Observable.
	 *
	 * @example <caption>Map every every click to the clientX position of that click</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var positions = clicks.map(ev => ev.clientX);
	 * positions.subscribe(x => console.log(x));
	 *
	 * @see {@link mapTo}
	 * @see {@link pluck}
	 *
	 * @param {function(value: T, index: number): R} project The function to apply
	 * to each `value` emitted by the source Observable. The `index` parameter is
	 * the number `i` for the i-th emission that has happened since the
	 * subscription, starting from the number `0`.
	 * @param {any} [thisArg] An optional argument to define what `this` is in the
	 * `project` function.
	 * @return {Observable<R>} An Observable that emits the values from the source
	 * Observable transformed by the given `project` function.
	 * @method map
	 * @owner Observable
	 */
	function map(project, thisArg) {
	    if (typeof project !== 'function') {
	        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
	    }
	    return this.lift(new MapOperator(project, thisArg));
	}
	exports.map = map;
	var MapOperator = (function () {
	    function MapOperator(project, thisArg) {
	        this.project = project;
	        this.thisArg = thisArg;
	    }
	    MapOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
	    };
	    return MapOperator;
	}());
	exports.MapOperator = MapOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MapSubscriber = (function (_super) {
	    __extends(MapSubscriber, _super);
	    function MapSubscriber(destination, project, thisArg) {
	        _super.call(this, destination);
	        this.project = project;
	        this.count = 0;
	        this.thisArg = thisArg || this;
	    }
	    // NOTE: This looks unoptimized, but it's actually purposefully NOT
	    // using try/catch optimizations.
	    MapSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.project.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return MapSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=map.js.map

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(20);
	var filter_1 = __webpack_require__(36);
	Observable_1.Observable.prototype.filter = filter_1.filter;
	//# sourceMappingURL=filter.js.map

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(23);
	/* tslint:disable:max-line-length */
	/**
	 * Filter items emitted by the source Observable by only emitting those that
	 * satisfy a specified predicate.
	 *
	 * <span class="informal">Like
	 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
	 * it only emits a value from the source if it passes a criterion function.</span>
	 *
	 * <img src="./img/filter.png" width="100%">
	 *
	 * Similar to the well-known `Array.prototype.filter` method, this operator
	 * takes values from the source Observable, passes them through a `predicate`
	 * function and only emits those values that yielded `true`.
	 *
	 * @example <caption>Emit only click events whose target was a DIV element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
	 * clicksOnDivs.subscribe(x => console.log(x));
	 *
	 * @see {@link distinct}
	 * @see {@link distinctUntilChanged}
	 * @see {@link distinctUntilKeyChanged}
	 * @see {@link ignoreElements}
	 * @see {@link partition}
	 * @see {@link skip}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates each value emitted by the source Observable. If it returns `true`,
	 * the value is emitted, if `false` the value is not passed to the output
	 * Observable. The `index` parameter is the number `i` for the i-th source
	 * emission that has happened since the subscription, starting from the number
	 * `0`.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {Observable} An Observable of values from the source that were
	 * allowed by the `predicate` function.
	 * @method filter
	 * @owner Observable
	 */
	function filter(predicate, thisArg) {
	    return this.lift(new FilterOperator(predicate, thisArg));
	}
	exports.filter = filter;
	var FilterOperator = (function () {
	    function FilterOperator(predicate, thisArg) {
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	    }
	    FilterOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
	    };
	    return FilterOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FilterSubscriber = (function (_super) {
	    __extends(FilterSubscriber, _super);
	    function FilterSubscriber(destination, predicate, thisArg) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.count = 0;
	        this.predicate = predicate;
	    }
	    // the try catch block below is left specifically for
	    // optimization and perf reasons. a tryCatcher is not necessary here.
	    FilterSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.predicate.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this.destination.next(value);
	        }
	    };
	    return FilterSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=filter.js.map

/***/ },
/* 37 */
/***/ function(module, exports) {

	module.exports = "<ng2-dropdown>\n    <ng2-dropdown-menu [focusFirstElement]=\"focusFirstElement\" [offset]=\"offset\">\n        <ng2-menu-item *ngFor=\"let item of items; let index = index;\"\n                       [value]=\"item\"\n                       [ngSwitch]=\"!!templates.length\">\n            <span *ngSwitchCase=\"false\"\n                  [innerHTML]=\"item.display | highlight : tagInput.inputForm.value.value\">\n            </span>\n\n            <template *ngSwitchDefault\n                      [ngTemplateOutlet]=\"templates.first\"\n                      [ngOutletContext]=\"{ item: item, index: index }\">\n            </template>\n        </ng2-menu-item>\n    </ng2-dropdown-menu>\n</ng2-dropdown>\n";

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(1);
	var tag_ripple_component_1 = __webpack_require__(39);
	var TagComponent = (function () {
	    function TagComponent(element, renderer) {
	        this.element = element;
	        this.renderer = renderer;
	        this.onSelect = new core_1.EventEmitter();
	        this.onRemove = new core_1.EventEmitter();
	        this.onBlur = new core_1.EventEmitter();
	        this.onKeyDown = new core_1.EventEmitter();
	        this.onTagEdited = new core_1.EventEmitter();
	        this.editModeActivated = false;
	        this.rippleState = 'none';
	    }
	    TagComponent.prototype.select = function ($event) {
	        if (this.readonly) {
	            return;
	        }
	        if ($event) {
	            $event.stopPropagation();
	        }
	        this.focus();
	        this.onSelect.emit(this.model);
	    };
	    TagComponent.prototype.remove = function () {
	        this.onRemove.emit(this);
	    };
	    TagComponent.prototype.focus = function () {
	        this.renderer.invokeElementMethod(this.element.nativeElement, 'focus');
	    };
	    TagComponent.prototype.keydown = function (event) {
	        if (this.editModeActivated) {
	            event.keyCode === 13 ? this.disableEditMode(event) : this.storeNewValue();
	            return;
	        }
	        this.onKeyDown.emit({ event: event, model: this.model });
	    };
	    TagComponent.prototype.blink = function () {
	        var classList = this.element.nativeElement.classList;
	        classList.add('blink');
	        setTimeout(function () { return classList.remove('blink'); }, 50);
	    };
	    TagComponent.prototype.toggleEditMode = function () {
	        if (this.editModeActivated) {
	            this.storeNewValue();
	        }
	        else {
	            this.element.nativeElement.querySelector('[contenteditable]').focus();
	        }
	        this.editModeActivated = !this.editModeActivated;
	        this.renderer.setElementClass(this.element.nativeElement, 'tag--editing', this.editModeActivated);
	    };
	    TagComponent.prototype.getDisplayValue = function (item) {
	        return typeof item === 'string' ? item : item[this.displayBy];
	    };
	    TagComponent.prototype.getContentEditableText = function () {
	        return this.element.nativeElement.querySelector('[contenteditable]').innerText.trim();
	    };
	    TagComponent.prototype.disableEditMode = function ($event) {
	        this.editModeActivated = false;
	        $event.preventDefault();
	    };
	    TagComponent.prototype.storeNewValue = function () {
	        var _this = this;
	        var input = this.getContentEditableText();
	        var exists = function (model) {
	            return typeof model === 'string' ?
	                model === input :
	                model[_this.identifyBy] === input;
	        };
	        if (exists(this.model)) {
	            var itemValue = this.model[this.identifyBy];
	            this.model = typeof this.model === 'string' ? input :
	                (_a = {}, _a[this.identifyBy] = itemValue, _a[this.displayBy] = itemValue, _a);
	            this.onTagEdited.emit(this.model);
	        }
	        var _a;
	    };
	    TagComponent.prototype.isDeleteIconVisible = function () {
	        return !this.readonly && this.removable && !this.editModeActivated;
	    };
	    TagComponent.prototype.isRippleVisible = function () {
	        return !this.readonly && !this.editModeActivated;
	    };
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Object)
	    ], TagComponent.prototype, "model", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Boolean)
	    ], TagComponent.prototype, "readonly", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Boolean)
	    ], TagComponent.prototype, "removable", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', Boolean)
	    ], TagComponent.prototype, "editable", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', core_1.TemplateRef)
	    ], TagComponent.prototype, "template", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagComponent.prototype, "displayBy", void 0);
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagComponent.prototype, "identifyBy", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], TagComponent.prototype, "onSelect", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], TagComponent.prototype, "onRemove", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], TagComponent.prototype, "onBlur", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], TagComponent.prototype, "onKeyDown", void 0);
	    __decorate([
	        core_1.Output(), 
	        __metadata('design:type', core_1.EventEmitter)
	    ], TagComponent.prototype, "onTagEdited", void 0);
	    __decorate([
	        core_1.ViewChild(tag_ripple_component_1.TagRipple), 
	        __metadata('design:type', tag_ripple_component_1.TagRipple)
	    ], TagComponent.prototype, "ripple", void 0);
	    __decorate([
	        core_1.HostListener('keydown', ['$event']), 
	        __metadata('design:type', Function), 
	        __metadata('design:paramtypes', [KeyboardEvent]), 
	        __metadata('design:returntype', void 0)
	    ], TagComponent.prototype, "keydown", null);
	    TagComponent = __decorate([
	        core_1.Component({
	            selector: 'tag',
	            template: __webpack_require__(40),
	            styles: [__webpack_require__(41)]
	        }), 
	        __metadata('design:paramtypes', [core_1.ElementRef, core_1.Renderer])
	    ], TagComponent);
	    return TagComponent;
	}());
	exports.TagComponent = TagComponent;
	

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(1);
	var TagRipple = (function () {
	    function TagRipple() {
	        this.state = 'none';
	    }
	    __decorate([
	        core_1.Input(), 
	        __metadata('design:type', String)
	    ], TagRipple.prototype, "state", void 0);
	    TagRipple = __decorate([
	        core_1.Component({
	            selector: 'tag-ripple',
	            styles: ["\n        :host {\n            width: 100%;\n            height: 100%;\n            left: 0;\n            overflow: hidden;\n            position: absolute;\n        }\n        \n        .tag-ripple {\n            background: rgba(0, 0, 0, 0.1);\n            top: 50%;\n            left: 50%;\n            height: 100%;\n            transform: translate(-50%, -50%);\n            position: absolute;\n        }\n    "],
	            template: "\n        <div class=\"tag-ripple\" [@ink]=\"state\"></div>\n    ",
	            animations: [
	                core_1.trigger('ink', [
	                    core_1.state('none', core_1.style({ width: 0, opacity: 0 })),
	                    core_1.transition('none => clicked', [
	                        core_1.animate(300, core_1.keyframes([
	                            core_1.style({ opacity: 1, offset: 0, width: '30%', borderRadius: '100%' }),
	                            core_1.style({ opacity: 1, offset: 0.5, width: '50%' }),
	                            core_1.style({ opacity: 0.5, offset: 1, width: '100%', borderRadius: '16px' })
	                        ]))
	                    ])
	                ])
	            ]
	        }), 
	        __metadata('design:paramtypes', [])
	    ], TagRipple);
	    return TagRipple;
	}());
	exports.TagRipple = TagRipple;
	

/***/ },
/* 40 */
/***/ function(module, exports) {

	module.exports = "<div (click)=\"select($event)\"\n     (dblclick)=\"editable ? toggleEditMode($event) : undefined\"\n     (mousedown)=\"rippleState='clicked'\"\n     (mouseup)=\"rippleState='none'\"\n     [ngSwitch]=\"!!template\"\n     [attr.tabindex]=\"-1\"\n     [attr.aria-label]=\"getDisplayValue(model)\">\n\n    <div *ngSwitchCase=\"true\" [attr.contenteditable]=\"editModeActivated\">\n        <!-- CUSTOM TEMPLATE -->\n        <template\n            [ngOutletContext]=\"{ item: model }\"\n            [ngTemplateOutlet]=\"template\">\n        </template>\n    </div>\n\n    <div *ngSwitchCase=\"false\">\n        <!-- TAG NAME -->\n        <span [attr.contenteditable]=\"editModeActivated\"\n              spellcheck=\"false\"\n              (keydown.enter)=\"disableEditMode($event)\"\n              (keydown.escape)=\"disableEditMode($event)\"\n              (click)=\"editModeActivated ? $event.stopPropagation() : undefined\"\n              (blur)=\"toggleEditMode()\">\n            {{ getDisplayValue(model) }}\n        </span>\n\n        <!-- 'X' BUTTON -->\n        <delete-icon\n            aria-label=\"Remove tag\"\n            role=\"button\"\n            (click)=\"remove()\"\n            *ngIf=\"isDeleteIconVisible()\">\n        </delete-icon>\n    </div>\n</div>\n\n<tag-ripple [state]=\"rippleState\" *ngIf=\"isRippleVisible()\"></tag-ripple>\n";

/***/ },
/* 41 */
/***/ function(module, exports) {

	module.exports = ":host, :host > div, :host > div:focus {\n  outline: 0;\n  overflow: hidden;\n  -webkit-transition: opacity 1s;\n  transition: opacity 1s;\n  z-index: 1; }\n\n:host.blink {\n  -webkit-animation: blink 0.3s normal forwards ease-in-out;\n  animation: blink 0.3s normal forwards ease-in-out; }\n\n@-webkit-keyframes blink {\n  0% {\n    opacity: 0.3; } }\n\n@keyframes blink {\n  0% {\n    opacity: 0.3; } }\n\n:host [contenteditable='true'] {\n  outline: 0;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none; }\n"

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(20);
	var debounceTime_1 = __webpack_require__(43);
	Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;
	//# sourceMappingURL=debounceTime.js.map

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(23);
	var async_1 = __webpack_require__(44);
	/**
	 * Emits a value from the source Observable only after a particular time span
	 * has passed without another source emission.
	 *
	 * <span class="informal">It's like {@link delay}, but passes only the most
	 * recent value from each burst of emissions.</span>
	 *
	 * <img src="./img/debounceTime.png" width="100%">
	 *
	 * `debounceTime` delays values emitted by the source Observable, but drops
	 * previous pending delayed emissions if a new value arrives on the source
	 * Observable. This operator keeps track of the most recent value from the
	 * source Observable, and emits that only when `dueTime` enough time has passed
	 * without any other value appearing on the source Observable. If a new value
	 * appears before `dueTime` silence occurs, the previous value will be dropped
	 * and will not be emitted on the output Observable.
	 *
	 * This is a rate-limiting operator, because it is impossible for more than one
	 * value to be emitted in any time window of duration `dueTime`, but it is also
	 * a delay-like operator since output emissions do not occur at the same time as
	 * they did on the source Observable. Optionally takes a {@link Scheduler} for
	 * managing timers.
	 *
	 * @example <caption>Emit the most recent click after a burst of clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.debounceTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounce}
	 * @see {@link delay}
	 * @see {@link sampleTime}
	 * @see {@link throttleTime}
	 *
	 * @param {number} dueTime The timeout duration in milliseconds (or the time
	 * unit determined internally by the optional `scheduler`) for the window of
	 * time required to wait for emission silence before emitting the most recent
	 * source value.
	 * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for
	 * managing the timers that handle the timeout for each value.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by the specified `dueTime`, and may drop some values if they occur
	 * too frequently.
	 * @method debounceTime
	 * @owner Observable
	 */
	function debounceTime(dueTime, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
	}
	exports.debounceTime = debounceTime;
	var DebounceTimeOperator = (function () {
	    function DebounceTimeOperator(dueTime, scheduler) {
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	    }
	    DebounceTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
	    };
	    return DebounceTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DebounceTimeSubscriber = (function (_super) {
	    __extends(DebounceTimeSubscriber, _super);
	    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
	        _super.call(this, destination);
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	        this.debouncedSubscription = null;
	        this.lastValue = null;
	        this.hasValue = false;
	    }
	    DebounceTimeSubscriber.prototype._next = function (value) {
	        this.clearDebounce();
	        this.lastValue = value;
	        this.hasValue = true;
	        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
	    };
	    DebounceTimeSubscriber.prototype._complete = function () {
	        this.debouncedNext();
	        this.destination.complete();
	    };
	    DebounceTimeSubscriber.prototype.debouncedNext = function () {
	        this.clearDebounce();
	        if (this.hasValue) {
	            this.destination.next(this.lastValue);
	            this.lastValue = null;
	            this.hasValue = false;
	        }
	    };
	    DebounceTimeSubscriber.prototype.clearDebounce = function () {
	        var debouncedSubscription = this.debouncedSubscription;
	        if (debouncedSubscription !== null) {
	            this.remove(debouncedSubscription);
	            debouncedSubscription.unsubscribe();
	            this.debouncedSubscription = null;
	        }
	    };
	    return DebounceTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchNext(subscriber) {
	    subscriber.debouncedNext();
	}
	//# sourceMappingURL=debounceTime.js.map

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AsyncAction_1 = __webpack_require__(45);
	var AsyncScheduler_1 = __webpack_require__(47);
	exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
	//# sourceMappingURL=async.js.map

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(21);
	var Action_1 = __webpack_require__(46);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AsyncAction = (function (_super) {
	    __extends(AsyncAction, _super);
	    function AsyncAction(scheduler, work) {
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	        this.pending = false;
	    }
	    AsyncAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (this.closed) {
	            return this;
	        }
	        // Always replace the current state with the new state.
	        this.state = state;
	        // Set the pending flag indicating that this action has been scheduled, or
	        // has recursively rescheduled itself.
	        this.pending = true;
	        var id = this.id;
	        var scheduler = this.scheduler;
	        //
	        // Important implementation note:
	        //
	        // Actions only execute once by default, unless rescheduled from within the
	        // scheduled callback. This allows us to implement single and repeat
	        // actions via the same code path, without adding API surface area, as well
	        // as mimic traditional recursion but across asynchronous boundaries.
	        //
	        // However, JS runtimes and timers distinguish between intervals achieved by
	        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
	        // serial `setTimeout` calls can be individually delayed, which delays
	        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
	        // guarantee the interval callback will be invoked more precisely to the
	        // interval period, regardless of load.
	        //
	        // Therefore, we use `setInterval` to schedule single and repeat actions.
	        // If the action reschedules itself with the same delay, the interval is not
	        // canceled. If the action doesn't reschedule, or reschedules with a
	        // different delay, the interval will be canceled after scheduled callback
	        // execution.
	        //
	        if (id != null) {
	            this.id = this.recycleAsyncId(scheduler, id, delay);
	        }
	        this.delay = delay;
	        // If this action has already an async Id, don't request a new one.
	        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
	        return this;
	    };
	    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
	    };
	    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If this action is rescheduled with the same delay time, don't clear the interval id.
	        if (delay !== null && this.delay === delay) {
	            return id;
	        }
	        // Otherwise, if the action's delay time is different from the current delay,
	        // clear the interval id
	        return root_1.root.clearInterval(id) && undefined || undefined;
	    };
	    /**
	     * Immediately executes this action and the `work` it contains.
	     * @return {any}
	     */
	    AsyncAction.prototype.execute = function (state, delay) {
	        if (this.closed) {
	            return new Error('executing a cancelled action');
	        }
	        this.pending = false;
	        var error = this._execute(state, delay);
	        if (error) {
	            return error;
	        }
	        else if (this.pending === false && this.id != null) {
	            // Dequeue if the action didn't reschedule itself. Don't call
	            // unsubscribe(), because the action could reschedule later.
	            // For example:
	            // ```
	            // scheduler.schedule(function doWork(counter) {
	            //   /* ... I'm a busy worker bee ... */
	            //   var originalAction = this;
	            //   /* wait 100ms before rescheduling the action */
	            //   setTimeout(function () {
	            //     originalAction.schedule(counter + 1);
	            //   }, 100);
	            // }, 1000);
	            // ```
	            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
	        }
	    };
	    AsyncAction.prototype._execute = function (state, delay) {
	        var errored = false;
	        var errorValue = undefined;
	        try {
	            this.work(state);
	        }
	        catch (e) {
	            errored = true;
	            errorValue = !!e && e || new Error(e);
	        }
	        if (errored) {
	            this.unsubscribe();
	            return errorValue;
	        }
	    };
	    AsyncAction.prototype._unsubscribe = function () {
	        var id = this.id;
	        var scheduler = this.scheduler;
	        var actions = scheduler.actions;
	        var index = actions.indexOf(this);
	        this.work = null;
	        this.delay = null;
	        this.state = null;
	        this.pending = false;
	        this.scheduler = null;
	        if (index !== -1) {
	            actions.splice(index, 1);
	        }
	        if (id != null) {
	            this.id = this.recycleAsyncId(scheduler, id, null);
	        }
	    };
	    return AsyncAction;
	}(Action_1.Action));
	exports.AsyncAction = AsyncAction;
	//# sourceMappingURL=AsyncAction.js.map

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(25);
	/**
	 * A unit of work to be executed in a {@link Scheduler}. An action is typically
	 * created from within a Scheduler and an RxJS user does not need to concern
	 * themselves about creating and manipulating an Action.
	 *
	 * ```ts
	 * class Action<T> extends Subscription {
	 *   new (scheduler: Scheduler, work: (state?: T) => void);
	 *   schedule(state?: T, delay: number = 0): Subscription;
	 * }
	 * ```
	 *
	 * @class Action<T>
	 */
	var Action = (function (_super) {
	    __extends(Action, _super);
	    function Action(scheduler, work) {
	        _super.call(this);
	    }
	    /**
	     * Schedules this action on its parent Scheduler for execution. May be passed
	     * some context object, `state`. May happen at some point in the future,
	     * according to the `delay` parameter, if specified.
	     * @param {T} [state] Some contextual data that the `work` function uses when
	     * called by the Scheduler.
	     * @param {number} [delay] Time to wait before executing the work, where the
	     * time unit is implicit and defined by the Scheduler.
	     * @return {void}
	     */
	    Action.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        return this;
	    };
	    return Action;
	}(Subscription_1.Subscription));
	exports.Action = Action;
	//# sourceMappingURL=Action.js.map

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Scheduler_1 = __webpack_require__(48);
	var AsyncScheduler = (function (_super) {
	    __extends(AsyncScheduler, _super);
	    function AsyncScheduler() {
	        _super.apply(this, arguments);
	        this.actions = [];
	        /**
	         * A flag to indicate whether the Scheduler is currently executing a batch of
	         * queued actions.
	         * @type {boolean}
	         */
	        this.active = false;
	        /**
	         * An internal ID used to track the latest asynchronous task such as those
	         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
	         * others.
	         * @type {any}
	         */
	        this.scheduled = undefined;
	    }
	    AsyncScheduler.prototype.flush = function (action) {
	        var actions = this.actions;
	        if (this.active) {
	            actions.push(action);
	            return;
	        }
	        var error;
	        this.active = true;
	        do {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        } while (action = actions.shift()); // exhaust the scheduler queue
	        this.active = false;
	        if (error) {
	            while (action = actions.shift()) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AsyncScheduler;
	}(Scheduler_1.Scheduler));
	exports.AsyncScheduler = AsyncScheduler;
	//# sourceMappingURL=AsyncScheduler.js.map

/***/ },
/* 48 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * An execution context and a data structure to order tasks and schedule their
	 * execution. Provides a notion of (potentially virtual) time, through the
	 * `now()` getter method.
	 *
	 * Each unit of work in a Scheduler is called an {@link Action}.
	 *
	 * ```ts
	 * class Scheduler {
	 *   now(): number;
	 *   schedule(work, delay?, state?): Subscription;
	 * }
	 * ```
	 *
	 * @class Scheduler
	 */
	var Scheduler = (function () {
	    function Scheduler(SchedulerAction, now) {
	        if (now === void 0) { now = Scheduler.now; }
	        this.SchedulerAction = SchedulerAction;
	        this.now = now;
	    }
	    /**
	     * Schedules a function, `work`, for execution. May happen at some point in
	     * the future, according to the `delay` parameter, if specified. May be passed
	     * some context object, `state`, which will be passed to the `work` function.
	     *
	     * The given arguments will be processed an stored as an Action object in a
	     * queue of actions.
	     *
	     * @param {function(state: ?T): ?Subscription} work A function representing a
	     * task, or some unit of work to be executed by the Scheduler.
	     * @param {number} [delay] Time to wait before executing the work, where the
	     * time unit is implicit and defined by the Scheduler itself.
	     * @param {T} [state] Some contextual data that the `work` function uses when
	     * called by the Scheduler.
	     * @return {Subscription} A subscription in order to be able to unsubscribe
	     * the scheduled work.
	     */
	    Scheduler.prototype.schedule = function (work, delay, state) {
	        if (delay === void 0) { delay = 0; }
	        return new this.SchedulerAction(this, work).schedule(state, delay);
	    };
	    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
	    return Scheduler;
	}());
	exports.Scheduler = Scheduler;
	//# sourceMappingURL=Scheduler.js.map

/***/ },
/* 49 */
/***/ function(module, exports) {

	module.exports = ".progress-bar, .progress-bar:before {\n  height: 2px;\n  width: 100%;\n  margin: 0; }\n\n.progress-bar {\n  background-color: #2196F3;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  position: absolute;\n  bottom: 0; }\n\n.progress-bar:before {\n  background-color: #82c4f8;\n  content: '';\n  -webkit-animation: running-progress 2s cubic-bezier(0.4, 0, 0.2, 1) infinite;\n  animation: running-progress 2s cubic-bezier(0.4, 0, 0.2, 1) infinite; }\n\n@-webkit-keyframes running-progress {\n  0% {\n    margin-left: 0;\n    margin-right: 100%; }\n  50% {\n    margin-left: 25%;\n    margin-right: 0; }\n  100% {\n    margin-left: 100%;\n    margin-right: 0; } }\n\n@keyframes running-progress {\n  0% {\n    margin-left: 0;\n    margin-right: 100%; }\n  50% {\n    margin-left: 25%;\n    margin-right: 0; }\n  100% {\n    margin-left: 100%;\n    margin-right: 0; } }\n\n.ng2-tag-input {\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: row;\n          flex-direction: row;\n  -ms-flex-wrap: wrap;\n      flex-wrap: wrap;\n  -webkit-transition: all 0.15s;\n  transition: all 0.15s;\n  padding: 0.25rem 0.2rem;\n  min-height: 32px;\n  cursor: text;\n  position: relative; }\n\n.ng2-tag-input:focus {\n  outline: 0; }\n\n.ng2-tags-container {\n  -ms-flex-wrap: wrap;\n      flex-wrap: wrap;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex; }\n\n.ng2-tag-input form {\n  margin: 0.1em 0; }\n\n.ng2-tag-input__error-message {\n  font-size: 0.8em;\n  color: #f44336;\n  margin: 0.5em 0; }\n\n.default.ng2-tag-input.ng2-tag-input--invalid, .minimal.ng2-tag-input.ng2-tag-input--invalid, .dark.ng2-tag-input.ng2-tag-input--invalid {\n  border-bottom: 2px solid #f44336; }\n\n.default.ng2-tag-input.ng2-tag-input--loading, .dark.ng2-tag-input.ng2-tag-input--loading, .minimal.ng2-tag-input.ng2-tag-input--loading {\n  border: none; }\n\n.ng2-tag-input.default {\n  border-bottom: 2px solid #efefef; }\n\n.default.ng2-tag-input--focused {\n  border-bottom: 2px solid #2196F3; }\n\n.ng2-tag-input.minimal {\n  border-bottom: 1px solid transparent; }\n\n.ng2-tag-input.dark {\n  border-bottom: 2px solid #212121; }\n\ntag {\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: row;\n          flex-direction: row;\n  -ms-flex-wrap: wrap;\n      flex-wrap: wrap;\n  font-family: \"Roboto\", \"Helvetica Neue\", sans-serif;\n  font-weight: 400;\n  font-size: 1em;\n  letter-spacing: 0.05rem;\n  outline: 0;\n  color: #444;\n  cursor: pointer;\n  border-radius: 16px;\n  -webkit-transition: all 0.25s;\n  transition: all 0.25s;\n  margin: 0.1rem 0.2rem;\n  padding: 0.08rem 0.45rem;\n  height: 32px;\n  line-height: 34px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  overflow: hidden; }\n\ntag.readonly {\n  cursor: default; }\n\ntag.readonly:focus {\n  outline: 0; }\n\n.default tag.tag--editing, .dark tag.tag--editing, .minimal tag.tag--editing {\n  background-color: #fff;\n  cursor: text; }\n\ntag:focus {\n  outline: 0; }\n\n.default tag:not(.tag--editing) {\n  background: #efefef; }\n\n.default tag:not(.readonly):not(.tag--editing):focus {\n  background: #2196F3;\n  color: #fff; }\n\n.default tag:not(.readonly):not(.tag--editing):active {\n  background: #0d8aee;\n  color: #fff; }\n\n.default tag:not(:focus):not(.tag--editing):not(:active):not(.readonly):hover {\n  background: #e2e2e2; }\n\n.minimal tag {\n  background: #f9f9f9;\n  border-radius: 0; }\n\n.minimal tag:not(.readonly):focus, .minimal tag:not(.readonly):active {\n  background: #dddddd; }\n\n.minimal tag:not(:focus):not(.readonly):hover {\n  background: #ececec; }\n\n.minimal tag:not(:focus):not(.readonly):hover {\n  background: #ececec; }\n\n.dark tag {\n  background: #212121;\n  color: #f9f9f9; }\n\n.dark tag:not(.readonly):focus, .dark tag:not(.readonly):active {\n  background: #999999;\n  color: #212121; }\n"

/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = "<!-- CONTAINER -->\n<div ngClass=\"ng2-tag-input {{ theme }}\"\n     (click)=\"focus(true)\"\n     [attr.tabindex]=\"-1\"\n     [class.ng2-tag-input--loading]=\"isLoading\"\n     [class.ng2-tag-input--invalid]=\"hasErrors()\"\n     [class.ng2-tag-input--focused]=\"isInputFocused()\">\n\n    <!-- TAGS -->\n    <div class=\"ng2-tags-container\">\n        <tag *ngFor=\"let item of items; let i = index\"\n             [@flyInOut]=\"'in'\"\n             (onSelect)=\"selectItem(item)\"\n             (onRemove)=\"removeItem(item, i)\"\n             (onKeyDown)=\"handleKeydown($event, item)\"\n             (onTagEdited)=\"onTagEdited.emit(item)\"\n             [attr.tabindex]=\"readonly ? -1 : 0\"\n             [class.readonly]=\"readonly\"\n             [readonly]=\"readonly\"\n             [removable]=\"removable\"\n             [editable]=\"editable\"\n             [displayBy]=\"displayBy\"\n             [identifyBy]=\"identifyBy\"\n             [template]=\"!!hasCustomTemplate() ? templates.first : undefined\"\n             [model]=\"item\">\n        </tag>\n\n        <tag-input-form\n            (onSubmit)=\"addItem()\"\n            (onBlur)=\"blur()\"\n            (onFocus)=\"focus()\"\n            (onKeydown)=\"fireEvents('keydown', $event)\"\n            (onKeyup)=\"fireEvents('keyup', $event)\"\n            (onKeypress)=\"handleKeyPress()\"\n            [validators]=\"validators\"\n            [hidden]=\"readonly || maxItemsReached\"\n            [placeholder]=\"items.length ? placeholder : secondaryPlaceholder\"\n            [inputClass]=\"inputClass\"\n            [inputId]=\"inputId\">\n        </tag-input-form>\n    </div>\n\n    <div class=\"progress-bar\" *ngIf=\"isLoading\"></div>\n</div>\n\n<!-- ERRORS -->\n<div class=\"ng2-tag-input__errors-container\" *ngIf=\"hasErrors()\">\n    <p *ngFor=\"let error of inputForm.getErrorMessages(errorMessages)\" class=\"ng2-tag-input__error-message\">\n        <span>{{ error }}</span>\n    </p>\n</div>\n";

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var core_1 = __webpack_require__(1);
	var escape = function (s) { return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'); };
	var HighlightPipe = (function () {
	    function HighlightPipe() {
	    }
	    HighlightPipe.prototype.transform = function (value, arg) {
	        if (!arg.trim()) {
	            return value;
	        }
	        try {
	            var regex = new RegExp("(" + escape(arg) + ")", 'i');
	            return value.replace(regex, '<b>$1</b>');
	        }
	        catch (e) {
	            return value;
	        }
	    };
	    HighlightPipe = __decorate([
	        core_1.Pipe({
	            name: 'highlight'
	        }), 
	        __metadata('design:paramtypes', [])
	    ], HighlightPipe);
	    return HighlightPipe;
	}());
	exports.HighlightPipe = HighlightPipe;
	

/***/ }
/******/ ])
});
;
//# sourceMappingURL=ng2-tag-input.map